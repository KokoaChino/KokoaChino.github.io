<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>JavaJUC 多线程 | 星开祈灵的个人博客</title><meta name="keywords" content="Java,锁,JUC,volatile,AQS,原子类,并发,线程池"><meta name="author" content="星开祈灵"><meta name="copyright" content="星开祈灵"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="JavaJUC 多线程"><meta name="application-name" content="JavaJUC 多线程"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="JavaJUC 多线程"><meta property="og:url" content="https://kokoachino.github.io/2024/11/16/13%20JavaJUC%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html"><meta property="og:site_name" content="星开祈灵的个人博客"><meta property="og:description" content="锁机制12345public static void main(String[] args) &amp;#123;    synchronized (Main.class) &amp;#123;        &amp;#x2F;&amp;#x2F; 同步代码块    &amp;#125;&amp;#125;  同步代码块的执行过程：  synchroniz"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://gitee.com/kokoachino/picture-bed/raw/master/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87.jpg?_r_=bd31497d-fe89-a8a0-d0d5-bb8e5bbf5de1"><meta property="article:author" content="星开祈灵"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/kokoachino/picture-bed/raw/master/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87.jpg?_r_=bd31497d-fe89-a8a0-d0d5-bb8e5bbf5de1"><meta name="description" content="锁机制12345public static void main(String[] args) &amp;#123;    synchronized (Main.class) &amp;#123;        &amp;#x2F;&amp;#x2F; 同步代码块    &amp;#125;&amp;#125;  同步代码块的执行过程：  synchroniz"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://kokoachino.github.io/2024/11/16/13%20JavaJUC%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: false,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":100,"languages":{"author":"作者: 星开祈灵","link":"链接: ","source":"来源: 星开祈灵的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '星开祈灵的个人博客',
  title: 'JavaJUC 多线程',
  postAI: '',
  pageFillDescription: '锁机制, 重量级锁, 轻量级锁, 自旋锁, 偏向锁, 锁消除和锁粗化, 锁消除, 锁粗化, JMM 内存模型, 重排序, volatile 关键字, happens-before 原则, 关键点, 常见规则, 作用, 锁框架, Lock, Condition, TimeUnit, LockSupport, 线程挂起, 线程唤醒, 可重入锁, 公平锁与非公平锁, 读写锁, 锁降级和锁升级, 队列同步器 AQS, 底层实现, AQS, 公平锁加锁, 公平锁解锁, 公平锁一定公平吗？, Condition 实现原理, 自行实现锁类, 原子类, 基本数据类, AtomicInteger, AtomicLong, AtomicBoolean, 数组类, AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray, ABA 问题及解决方案, 并发容器, CopyOnWriteArrayList, ConcurrentHashMap, 阻塞队列, ArrayBlockingQueue, SynchronousQueue, LinkedBlockingQueue, PriorityBlockingQueue, DelayQueue, 并发工具, 计数器锁 CountDownLatch, 循环屏障 CyclicBarrier, 信号量 Semaphore, 数据交换 Exchanger, Forkx2FJoin 框架, 线程池, 线程池的使用, 构造方法, 示例, 执行带返回值的任务, 执行定时任务, 线程池实现原理, 字段, 方法, 执行任务, 关闭线程池, shutdown, shutdownNow锁机制同步代码块同步代码块的执行过程使用的锁存储在对象头中每个对象内部都有一部分空间用于存储对象头信息包含了用于存放和对象的锁信息重量级锁在之前一直被称为重量级锁每个对象都有一个与之关联在虚拟机中是由实现的记录个数处于状态的线程会被加入到处于等待锁状态的线程会被加入到该列表每个等待锁的线程都会被封装成对象进入到如下机制进入等待当线程获取到对象的后进入区域并把中的设置为当前线程同时中若当前线程执行完毕或调用方法将会释放当前持有的并把中的设置为同时中该线程进入集合中等待被唤醒轻量级锁在时引入了轻量级锁轻量级锁的目标是在无竞争情况下减少重量级锁产生的性能消耗它的运作机制如下在即将开始执行同步代码块中的内容时会首先检查对象的查看锁对象是否被其他线程占用如果没有任何线程占用那么会在当前线程中所处的栈帧中建立一个名为锁记录的空间用于复制并存储对象目前的信息虚拟机将使用操作将对象的更新为轻量级锁状态是一种无锁算法用于避免线程在操作共享资源时的互斥锁或其他锁机制降低并发性能瓶颈的操作步骤如下线程检查内存地址的当前值是否与预期值相同如果相同则将该内存位置的值更新为新值如果不同操作将失败并且不会改变内存中的值线程可以重新读取内存值并重新尝试如果操作失败了的话那么说明可能这时有其他线程已经进入这个同步代码块了这时虚拟机会再次检查对象的是否指向当前线程的栈帧如果是说明是当前线程已经有了这个对象的锁这时直接进同步代码块即可否则只能将锁膨胀为重量级锁按照重量级锁的操作执行注意锁的膨胀是不可逆的自旋锁在时引入了自旋锁之后默认开启它不会将处于等待状态的线程挂起而是通过无限循环的方式不断检测是否能够获取锁由于单个线程占用锁的时间非常短所以说循环次数不会太多可能很快就能够拿到锁并运行自旋锁的等待时间是有限制的默认情况下为次如果失败那么会进而采用重量级锁机制在之后自旋锁得到了一次优化自旋的次数限制不再是固定的而是自适应变化的轻量级锁失败自适应自旋锁失败重量级锁偏向锁偏向锁实际上就是专门为单个线程而生的当某个线程第一次获得锁时如果接下来都没有其他线程获取此锁那么持有锁的线程将不再需要进行同步操作偏向锁也会通过操作记录线程的如果一直都是同一个线程获取此锁那么完全没有必要在进行额外的操作当然如果有其他线程来抢了那么偏向锁会根据当前状态决定是否要恢复到未锁定或是膨胀为轻量级锁可以添加参数来开启偏向锁值得注意的是如果对象通过调用方法计算过对象的一致性哈希值那么它是不支持偏向锁的会直接进入到轻量级锁状态因为偏向锁的数据结构无法保存哈希值如果对象已经是偏向锁状态再去调用方法那么会直接将锁升级为重量级锁所以最终锁的等级为未锁定偏向锁轻量级锁重量级锁锁消除和锁粗化锁消除锁消除是在编译时的一种优化技术旨在消除不必要的锁当检测到某个对象的锁只在单线程中被使用且不会在多个线程间共享时它会自动消除锁避免不必要的同步开销锁粗化锁粗化是将多个相近的锁操作合并成一个更大的锁范围这样做可以减少频繁的锁操作降低上下文切换和加锁释放的开销尤其是在多个连续的同步操作中内存模型内存模型规定如下所有的变量全部存储在主内存每条线程有着自己的工作内存类比的高速缓存线程对变量不包括局部变量的所有操作必须在工作内存中进行不能直接操作主内存中的数据不同线程之间的工作内存相互隔离如果需要在线程之间传递内容只能通过主内存完成无法直接访问对方的工作内存也就是说每一条线程如果要操作主内存中的数据那么得先拷贝到自己的工作内存中并对工作内存中数据的副本进行操作操作完成之后也需要从工作副本中将结果拷贝回主内存中缓存不一致示例不符合预期实际上自增操作并不是由一条指令完成的包括变量的获取修改保存都是被拆分为一个一个的操作完成的那么这个时候就有可能出现在修改完保存之前另一条线程也保存了但是当前线程是毫不知情的这可以通过添加关键字使其变为同步代码块解决重排序在编译或执行时为了优化程序的执行效率编译器或处理器常常会对指令进行重排序有以下情况编译器重排序编译器通过对代码语义的理解根据优化规则对代码指令进行重排序机器指令级别的重排序现代处理器很高级能够自主判断和变更机器指令的执行顺序指令重排序能够在不改变结果单线程的情况下优化程序的运行效率比如其实可以交换第一行和第二行即使发生交换但是程序最后的运行结果是不会变的虽然单线程下指令重排确实可以起到一定程度的优化作用但是在多线程下似乎会导致一些问题上面这段代码在正常情况下是不可能输出的因为只要那么肯定有因为是在之前完成的赋值但是如果进行了重排序那么就有可能和的赋值发生了交换先被赋值为而恰巧这个时候线程已经开始判定了这时还没来得及被赋值为可能线程就已经走到打印那里去了所以是有可能输出的关键字多线程编程中的三个重要概念原子性一个操作要么完全成功要么完全失败不能被中断可见性一个线程对共享变量的修改能立即被其他线程看到有序性确保指令执行的顺序性可见性示例线程结束修改的值按照正常的逻辑来说的值被修改后那么另一个线程将不再循环虽然主线程中修改了的值但是另一个线程并不知道的值发生了改变所以循环中依然是使用旧值在进行判断因此普通变量是不具有可见性的解决方案添加关键字以保证变量的可见性当写入一个变量时会确保该线程将本地内存中的变量刷新到主内存中同时其他线程中的相同变量的缓存会失效确保其他线程能看到最新的值线程结束线程正常结束修改的值虽然说能够保证可见性但是不能保证原子性要解决之前的的问题目前还是只能使用加锁来完成最后一个功能就是会禁止指令重排也就是说如果操作的是一个变量它将不会出现重排序的情况如果使用修饰共享变量在编译时会在指令序列中插入内存屏障来禁止特定类型的处理器重排序内存屏障又称内存栅栏是一个指令它的作用有两个保证特定操作的顺序保证某些变量的内存可见性屏障类型指令示例说明读操作读操作写操作写操作读操作写操作写操作读操作所以能够保证之前的指令一定全部执行之后的指令一定都没有执行并且前面语句的结果对后面的语句都可见原则原则先行发生原则是中非常重要的一个概念它定义了多线程程序中操作的执行顺序简单来说它规定了当一个操作在另一个操作之前执行时前一个操作的结果对于后一个操作是可见的具体来说原则用于回答以下问题如果线程对某个共享变量进行修改线程在某个时刻读取该变量线程能否看到线程修改后的值关键点定义了操作之间的顺序关系确保先执行的操作的结果对后执行的操作可见如果操作操作那么线程必定能够看到线程对共享变量的修改它不仅限于内存可见性还涉及到程序执行的顺序性常见规则程序顺序规则在一个线程中按照程序中代码的顺序先执行的操作后执行的操作这里的计算的值被读取监视器锁规则对一个锁的解锁操作后续对同一个锁的加锁操作写操作这里的解锁后续线程对同一锁的加锁操作读操作变量规则对变量的写操作后续对该变量的读操作换句话说如果线程写入一个变量线程读取该变量线程能看到线程修改后的值线程写操作线程读操作线程看到线程写入的的最新值线程启动规则在启动一个新线程时线程的启动操作线程中的任何操作线程的任务线程的线程中的任何操作线程终止规则线程的操作线程终止后的操作即调用方法的线程会等待被调用线程结束然后继续执行线程的结束线程之后的操作作用内存可见性确保先发生的操作对后发生的操作是可见的避免乱序执行通过指定操作顺序避免或硬件在优化时造成不必要的乱序执行保障正确性帮助确保程序的正确性特别是在多线程并发场景下避免了出现竞态条件和数据不一致等问题锁框架在之后并发包中新增了接口以及相关实现类用来实现锁功能接口提供了与关键字类似的同步功能但需要在使用时手动获取锁和释放锁提供了一种比传统的关键字更灵活功能更强大的锁机制获取锁若锁被占用则会阻塞直到获取锁获取锁但可以响应中断尝试获取锁如果获取不到立即返回尝试获取锁最多等待指定的时间时间单位由参数指定释放锁返回一个新的实例用于实现线程间的等待和通知示例可重入锁类是类的一个实现加锁解锁提供比传统的类中的和方法更加灵活和强大的线程间通信机制与对象的方法类似进入等待状态并在被或唤醒后继续执行同时等待状态下可以响应中断同上但不会响应中断等待指定纳秒时间如果被唤醒则返回剩余时间否则超时返回或负值可以响应中断等待指定时间时间单位可指定如果在指定时间内被唤醒则返回否则返回可以响应中断等待直到指定的时间点如果在指定时间前被唤醒返回否则返回可以响应中断唤醒一个在等待状态中的线程唤醒后线程需要重新获得锁才能继续执行唤醒所有在等待状态中的线程唤醒的线程需重新获得锁才能继续执行示例线程进入等待状态进入等待状态线程等待结束线程开始唤醒其他等待线程唤醒线程但是此时线程还必须要拿到锁才能继续运行线程结束这里释放锁之后线程就可以拿到锁继续运行了线程进入等待状态线程开始唤醒其他等待线程线程结束线程等待结束进程已结束退出代码为示例线程进入等待状态进入等待状态线程等待结束线程开始唤醒其他等待线程与线程使用的是不同的对象所以不能唤醒线程线程结束这里释放锁之后线程还是在阻塞状态线程进入等待状态线程开始唤醒其他等待线程线程结束进程已结束退出代码为同一把锁内是可以存在多个对象的只有对同一个对象进行等待和唤醒操作才会有效而不同的对象是分开计算的提供了一些便捷的方法来进行时间的转换和管理字段描述纳秒微秒毫秒秒分钟小时天方法描述将给定时间单位转换为纳秒将给定时间单位转换为微秒将给定时间单位转换为毫秒将给定时间单位转换为秒将给定时间单位转换为分钟将给定时间单位转换为小时将给定时间单位转换为天将给定的时间单位转换为当前时间单位使当前线程休眠指定的时间单位由调用的枚举值决定用来进行线程的挂起和唤醒操作线程挂起使当前线程挂起直到被唤醒或中断挂起的线程会释放持有的锁并且会处于阻塞状态线程唤醒线程唤醒指定的线程使它从状态中恢复执行可重入锁同一个线程可以反复进行加锁操作连续加锁次线程想要获取锁线程成功获取到锁线程释放了一次锁线程再次释放了一次锁释放全部锁后其他线程才能加锁在当前线程持有锁的情况下继续加锁不会被阻塞并且加锁几次就必须要解锁几次否则此线程依旧持有锁当前加锁次数是否被锁实际上如果存在线程持有当前的锁那么其他线程在获取锁时是会暂时进入到等待队列的当前锁的等待队列长度线程线程是否正在等待获取锁状态查看同一个目前有多少线程处于等待状态公平锁与非公平锁锁分为公平锁和非公平锁公平锁多个线程按照申请锁的顺序去获得锁线程会直接进入队列去排队永远都是队列的第一位才能得到锁非公平锁多个线程去获取锁的时候会直接去尝试获取获取不到再去进入等待队列如果能获取到就直接获取到锁创建出来的可重入锁默认是采用的非公平锁作为底层锁机制读写锁它和可重入锁不同的地方在于可重入锁是一种排他锁当一个线程得到锁之后另一个线程必须等待其释放锁否则一律不允许获取到锁读写锁维护了一个读锁和一个写锁这两个锁的机制是不同的读锁在没有任何线程占用写锁的情况下同一时间可以有多个线程加读锁写锁在没有任何线程占用读锁的情况下同一时间只能有一个线程加写锁获取读锁获取写锁此接口有一个实现类可以多个线程同时对读锁加锁有读锁状态下无法加写锁有写锁状态下无法加读锁不仅具有读写锁的功能还保留了可重入锁和公平非公平机制同一个线程可以重复为写锁加锁成功获取到写锁释放第一层锁释放第二层锁锁降级和锁升级锁降级写锁降级为读锁当一个线程持有写锁的情况下虽然其他线程不能加读锁但是线程自己是可以加读锁的添加读锁成功加读锁开始加读锁读锁添加成功在同时加了写锁和读锁的情况下释放写锁锁降级锁升级读锁升级为写锁在仅持有读锁的情况下去申请写锁是不支持的锁升级成功进程已结束退出代码为队列同步器公平锁和非公平锁都是继承自而是继承自简称队列同步器非公平锁公平锁底层实现是实现锁机制的基础它的内部封装了包括锁的获取释放以及等待队列一个锁排他锁为例的基本功能就是获取锁释放锁当锁被占用时其他线程来争抢会进入等待队列已经将这些基本的功能封装完成了其中等待队列是核心内容等待队列是由双向链表数据结构实现的每个等待状态下的线程都可以被封装进结点中并放入双向链表中而对于双向链表是以队列的形式进行操作的中有一个字段和一个字段分别记录双向链表的头结点和尾结点而之后的一系列操作都是围绕此队列来进行的的每个处于等待状态的线程都可以是一个节点并且每个节点是有很多状态的每个节点都可以被分为独占模式节点或是共享模式节点分别适用于独占锁和共享锁独占模式节点为空唯一一个大于的状态表示已失效可能是由于超时或中断此节点被取消此节点后面的节点被挂起进入等待状态在条件队列中的节点才是这个状态传播一般用于共享锁等待状态值双向链表中的前一个节点双向链表中的下一个节点每一个线程都可以被封装进一个节点进入到等待队列在等待队列中表示模式条件队列中作为下一个节点的指针判断节点是否为共享模式获取前一个节点带线程和模式的构造函数设置节点模式设置节点线程带线程和等待状态的构造函数设置节点的等待状态设置节点线程初始化操作直接使用类进行操作记录类中属性的在内存中的偏移地址方便类直接操作内存进行赋值等这里对应的就是类中的头结点成员字段这里对应的就是类中的成员字段这里对应的就是类中的成员字段这里对应的就是类中的成员字段静态代码块在类加载的时候就会自动获取偏移地址通过操作来修改头结点调用的是类的方法通过算法比较对象并替换同上省略部分代码通过操作来修改尾结点通过操作来修改的状态通过操作来修改的节点可重写方法独占式获取同步状态查看同步状态是否和参数一致如果没有问题那么会使用操作设置同步状态并返回独占式释放同步状态共享式获取同步状态返回值大于表示成功否则失败共享式释放同步状态是否在独占模式下被当前线程占用锁是否被当前线程持有公平锁加锁此类是全局独占式的中的公平锁是如何借助实现的加锁操作调用了提供的模板方法保护被注解的方法通过添加一些额外的空间防止在多线程运行的时候出现栈溢出节点为独占模式首先会调用方法这里是由类实现的如果尝试加独占锁失败返回了说明可能这个时候有其他线程持有了此独占锁所以当前线程得先等着那么会调用方法将线程加入等待队列中创建一个新的节点将当前线程和模式传入构造函数获取尾节点将新节点的前驱指向尾节点尝试通过将尾节点设置为新节点如果成功将尾节点的指向新节点返回新节点快速入队失败时调用方法进行自旋入队返回新节点自旋入队进行无限循环获取当前尾节点如果尾节点为说明头结点和尾结点都还没有初始化初始化头结点和尾结点将尾节点指向头节点将新节点的前驱指向当前尾节点尝试通过将尾节点设置为新节点如果成功将当前尾节点的指向新节点返回当前尾节点会返回已经加入的节点在得到返回的节点时也会进入自旋状态等待唤醒也就是开始进入到拿锁的环节了无限循环直到获取锁成功或出现错误获取当前节点的前驱节点可以看到当此节点位于队首时会再次调用方法获取锁如果获取成功会返回此过程中是否被中断的值新的头结点设置为当前节点原有的头结点没有存在的意义了获取锁成功标志设为直接返回等待过程中是否被中断依然没获取成功继续进行自旋将当前节点的前驱节点等待状态设置为如果失败将直接开启下一轮循环直到成功为止如果成功接着往下挂起线程进入等待状态等待被唤醒如果在等待状态下被中断那么会返回直接将中断标志设为否则就是正常唤醒继续自旋标记当前线程被中断如果获取锁失败取消当前节点的获取请求通过类操作底层挂起线程会直接进入阻塞状态检查并清除中断状态返回当前线程是否被中断获取前驱节点的等待状态已经是直接返回不能是已经取消的节点必须找到一个没被取消的将节点的前驱指针更新为前驱节点的前驱继续向前查找直到遇到一个没有被取消的节点直接抛弃被取消的节点连接当前节点不是先设置为这里没有返回因为不一定成功需要下一轮再判断一次尝试通过设置前驱节点的等待状态为返回马上开启下一轮循环所以中的条件如果为那么只有一种情况就是等待过程中被中断了其他任何情况下都是成功获取到独占锁所以当等待过程被中断时会调用方法直接向当前线程发送中断信号公平锁的方法先获取当前线程的对象获取当前对象状态独占模式下为未占用大于表示已占用如果是那就表示没有占用现在线程就要来尝试占用它等待队列是否不为空且当前线程没有拿到锁其实就是看看当前线程有没有必要进行排队如果没必要排队就说明可以直接获取锁设置状态如果成功则说明成功拿到了这把锁失败则说明可能这个时候其他线程在争抢并且还先抢到成功拿到锁会将独占模式所有者线程设定为当前线程这个方法是父类中的就表示当前这把锁已经是这个线程的了占用锁成功返回如果不是那就表示被线程占用了这个时候看看是不是自己占用的如果是由于是可重入锁可以继续加锁多次加锁会将状态值进行增加状态值就是加锁次数加到值溢出了设置为新的加锁次数成功加锁返回其他任何情况都是加锁失败公平锁解锁的解锁过程直接调用了中的方法参数为表示解锁一次和一样也得子类去重写释放锁操作释放锁成功后获取新的头结点如果新的头结点不为空并且不是刚刚建立的结点初始状态下为默认值而上面在进行了之后会被设定为状态值为唤醒头节点下一个节点中的线程释放锁成功释放锁失败定义方法用于唤醒下一个节点获取当前节点的等待状态如果等待状态小于即节点处于被中断或取消的状态将当前节点的等待状态设置为初始值获取下一个节点如果下一个节点为空或等待状态大于表示该节点已被取消不能通知将下一个节点设为从队尾向前遍历节点直到找到一个等待状态小于等于的节点如果找到了符合条件的节点更新为找到的节点如果找到了合适的节点唤醒该节点所对应的线程的尝试释放锁返回是否释放成功先计算本次解锁之后的状态值因为是独占锁那肯定这把锁得是当前线程持有才行否则直接抛异常用于标记是否成功释放锁如果解锁之后的值为表示已经完全释放此锁设置释放标志为将独占锁持有线程设置为状态值设定为如果不是表示此锁还没完全释放返回是就返回公平锁一定公平吗来回顾一下方法的实现注意这里公平锁的机制是一开始会查看是否有节点处于等待如果前面的方法执行后发现没有等待节点就直接进入占锁环节了假如现在出现了这样的情况线程已经持有锁了这时线程来争抢这把锁走到判断出为线程继续运行然后线程肯定获取锁失败因为锁这时是被线程占有的因此就进入到等待队列中由于一开始和都是所以线程直接就进了线程进来之后肯定是要先走这里的因为和都是这里就将直接等于了注意这里完了之后还没完这里只是初始化过程而碰巧不巧这个时候线程也来抢锁了按照正常流程走到了方法而在此方法中这里直接判断而此时线程才刚刚执行完所以直接就返回了因此线程这时就紧接着准备开始操作了又碰巧这时线程释放锁了现在的情况就是线程直接开始判断而线程还在插入节点状态结果可想而知居然是线程先拿到了锁这显然是违背了公平锁的公平机制因此公不公平全看而此方法只有在等待队列中存在节点时才能保证不会出现问题所以公平锁只有在等待队列存在节点时才是真正公平的实现原理在中有一个实现类而这里也是使用了链表实现了条件队列条件队列的头结点条件队列的尾结点这里是直接使用了中的类但是使用的是类中的字段连接节点并且的为当一个线程调用方法时会进入等待状态直到其他线程调用方法将其唤醒而这里的条件队列正是用于存储这些处于等待状态的线程方法的目标只有已经持有锁的线程才可以使用此方法当调用此方法后会直接释放锁无论加了多少次锁只有其他线程调用或是被中断时才会唤醒等待中的线程被唤醒后需要等待其他线程释放锁拿到锁之后才可以继续执行并且会恢复到之前的状态如果在调用之前就被添加了中断标记那么会直接抛出中断异常为当前线程创建一个新的节点并将其加入到条件队列中完全释放当前线程持有的锁并且保存一下值因为唤醒之后还得恢复用于保存中断状态循环判断是否位于同步队列中如果等待状态下的线程被其他线程唤醒那么会正常进入到的等待队列中如果依然处于等待状态那么继续挂起看看等待的时候是不是被中断了出了循环之后那线程肯定是已经醒了这时就差拿到锁就可以恢复运行了直接开始尝试拿锁之前已经讲过了从这里开始基本就和一个线程去抢锁是一样的了已经拿到锁了基本可以开始继续运行了这里再进行一下后期清理工作将等待队列中不是状态的节点移除依然是响应中断方法的目标只有持有锁的线程才能唤醒锁所属的等待的线程优先唤醒条件队列中的第一个如果唤醒过程中出现问题接着找往下找直到找到一个可以唤醒的唤醒操作本质上是将条件队列中的结点直接丢进等待队列中让其参与到锁的竞争中拿到锁之后线程才能恢复运行先看看当前线程是不是持有锁的状态获取条件队列的第一个结点如果队列不为空获取到了那么就可以开始唤醒操作执行唤醒操作定义方法处理条件队列中的信号开始循环处理队列中的节点如果当前节点在本轮循环没有后继节点了条件队列就为空了所以这里相当于是直接清空将给定节点的下一个结点设置为因为当前结点马上就会离开条件队列了能走到这里只能说明给定节点被设定为了取消状态那就继续看下一个结点定义方法用于处理节点的信号传递如果操作失败表示节点的等待状态已经被取消返回成功之后节点的等待状态变成默认值接着通过方法将节点丢进的等待队列相当于唤醒并等待获取锁将节点加入到的等待队列返回队尾的前驱节点保存前驱节点的等待状态如果上一个节点的状态为取消或者尝试设置上一个节点的状态为失败可能是在判断完之后马上变成取消状态导致失败如果前驱节点的等待状态为取消或者操作失败直接唤醒当前节点对应的线程返回表示节点成功传递了信号自行实现锁类要求同一时间只能有一个线程持有锁不要求可重入反复加锁无视即可自行实现一个最普通的独占锁设计思路锁被占用那么应该被记录并且锁没有被占用那么为并且无需可重入功能如果是当前线程直接返回操作进行状态替换成功后设置当前的所有者线程没加锁情况下是不能直接解锁的只有持有锁的线程才能解锁设置所有者线程为状态变为原子类基本数据类原子更新值获取当前值设置为指定的新值获取当前值并将其更新为新值返回旧值如果当前值等于预期值则将其更新为新值获取当前值并递增将当前值递增并返回更新后的新值获取当前值并递减将当前值递减并返回更新后的新值将当前值增加指定的值并返回新值获取当前值并将指定的值加到当前值返回旧值获取当前值的字符串表示返回当前值的普通类型返回当前值的类型返回当前值的类型返回当前值的类型与类似但使用弱一致性原子更新值获取当前值设置为指定的新值获取当前值并将其更新为新值返回旧值如果当前值等于预期值则将其更新为新值获取当前值并递增将当前值递增并返回更新后的新值获取当前值并递减将当前值递减并返回更新后的新值将当前值增加指定的值并返回新值获取当前值并将指定的值加到当前值返回旧值获取当前值的字符串表示返回当前值的普通类型返回当前值的类型返回当前值的类型返回当前值的类型与类似但使用弱一致性原子更新获取当前值设置为指定的新值获取当前值并将其更新为新值返回旧值如果当前值等于预期值则将其更新为新值获取当前值的字符串表示数组类原子更新数组数组获取指定索引的当前值设置指定索引的值为新值获取指定索引的当前值并将其更新为新值返回旧值如果指定索引的当前值等于预期值则将其更新为新值获取指定索引的当前值并递增返回旧值将指定索引的值递增并返回更新后的新值获取指定索引的当前值并递减返回旧值将指定索引的值递减并返回更新后的新值将指定索引的值增加指定的增量并返回新值获取指定索引的当前值并将指定的增量加到当前值返回旧值返回数组的长度获取当前值的字符串表示获取指定索引的原子值可以用来处理更多自定义操作原子更新数组数组获取指定索引的当前值设置指定索引的值为新值获取指定索引的当前值并将其更新为新值返回旧值如果指定索引的当前值等于预期值则将其更新为新值获取指定索引的当前值并递增返回旧值将指定索引的值递增并返回更新后的新值获取指定索引的当前值并递减返回旧值将指定索引的值递减并返回更新后的新值将指定索引的值增加指定的增量并返回新值获取指定索引的当前值并将指定的增量加到当前值返回旧值返回数组的长度获取当前数组值的字符串表示获取指定索引的原子值用于处理更复杂的操作返回指定索引的值的类型返回指定索引的值的类型返回指定索引的值的类型返回指定索引的值的类型原子更新引用数组数组获取指定索引的当前值设置指定索引的值为新值获取指定索引的当前值并将其更新为新值返回旧值如果指定索引的当前值等于预期值则将其更新为新值延迟设置指定索引的值可能不会立即生效返回数组的长度获取当前数组值的字符串表示获取指定索引的引用值在某些实现中可能为其他操作使用给定的更新函数更新并返回旧值使用给定的更新函数更新并返回新值使用给定的累加器函数更新值并返回旧值使用给定的累加器函数更新值并返回新值返回指定索引的值的类型返回指定索引的值的类型返回指定索引的值的类型返回指定索引的值的类型问题及解决方案问题引入线程和线程同时开始对的值进行修改但是线程的速度比较快将的值修改为之后紧接着又修改回这时线程才开始进行判断发现的值是所以操作成功很明显这里的已经不是一开始的那个了而是被重新赋值的这也是操作存在的问题它只会机械地比较当前值是不是预期值但是并不会关心当前值是否被修改过这种问题称之为问题解决方案提供了带版本号的引用类型只要每次操作都记录一下版本号并且版本号不会重复那么就可以解决问题了在构造时需要指定初始值和对应的版本号可以中途对版本号进行修改注意要填写当前的引用对象操作时不仅需要提供预期值和修改值还要提供预期版本号和新的版本号并发容器方法同方法同阻塞队列固定大小大小在创建时就必须指定并且大小是固定的它不会自动扩容阻塞操作它支持阻塞式的插入和移除操作当队列已满时生产者线程会被阻塞直到队列有空余位置当队列为空时消费者线程会被阻塞直到队列中有元素可供消费线程安全内部通过使用锁确保多线程的安全性在多个线程之间对队列进行插入删除等操作时它能避免数据不一致的问题公平性可以选择公平性策略如果使用公平锁会按照线程请求的顺序处理队列操作防止线程饥饿否则线程的执行顺序是无序的创建一个指定容量的队列默认不使用公平性创建一个指定容量的队列并指定是否使用公平性插入元素如果队列已满则抛出插入元素如果队列已满返回非阻塞尝试在指定时间内插入元素如果队列已满则阻塞指定时间插入元素如果队列已满则阻塞直到有空间移除并返回队头元素如果队列为空则阻塞尝试移除并返回队头元素如果队列为空则阻塞指定时间移除并返回队头元素如果队列为空则返回非阻塞返回队头元素但不移除如果队列为空返回移除队头元素如果队列为空则抛出异常返回队列当前元素的个数判断队列是否为空判断队列是否已满清空队列中的所有元素零容量队列它不存储任何元素每个插入操作必须等待另一个线程的移除操作反之亦然线程同步它用于在两个线程之间进行数据交换当一个线程插入元素时它必须等待另一个线程将其取走同样当一个线程试图取出元素时它必须等待另一个线程插入元素不支持缓存没有缓存功能它不会缓存任何元素因此每次插入和移除操作都必须在两个线程之间进行同步无容量队列的容量为零因此它是实现线程间交换的理想工具常用于实现线程池任务的处理创建一个新的空的默认是非公平的创建一个新的空的可以指定是否使用公平性策略插入元素如果队列为空则阻塞直到另一个线程调用获取元素移除并返回队头元素如果队列为空则阻塞直到另一个线程调用插入元素尝试在指定时间内移除并返回队头元素如果队列为空则阻塞指定时间尝试移除并返回队头元素如果队列为空则返回非阻塞判断队列是否为空返回队列当前元素的数量始终为或清空队列中的所有元素此方法通常不适用因为队列中没有持久存储的元素有容量的阻塞队列一个基于链表实现的阻塞队列它可以选择指定容量也可以使用默认的无界容量通过容量控制线程之间的同步线程安全可以在多个线程间安全地进行插入和移除操作支持阻塞操作如果队列满了插入操作会阻塞如果队列空了移除操作会阻塞适用于生产者消费者模型由于其线程安全和阻塞特性它广泛用于生产者消费者问题的解决方案适合任务调度和线程池的实现创建一个默认容量为的创建一个指定容量的插入元素如果队列已满则阻塞直到有空间可用移除并返回队头元素如果队列为空则阻塞直到有元素可用尝试插入元素如果队列未满则返回否则返回非阻塞尝试在指定时间内插入元素如果队列未满则返回否则返回带超时尝试在指定时间内移除并返回队头元素如果队列为空则阻塞指定时间尝试移除并返回队头元素如果队列为空则返回非阻塞返回队头元素但不移除它如果队列为空则返回判断队列是否为空返回队列当前元素的数量清空队列中的所有元素移除队列中的所有元素并将其添加到给定的集合中优先级队列一个支持优先级排序的阻塞队列队列中的元素根据其优先级进行排序优先级高的元素会先被移除默认使用元素的自然顺序或者可以通过提供自定义的比较器来控制排序线程安全可以在多个线程中安全地进行插入和移除操作无界队列它是一个无界队列即队列的容量仅受系统可用内存的限制不会因为达到容量限制而阻塞插入操作插入操作会继续直到内存不足阻塞操作尽管它是无界的它仍然可以进行阻塞操作当调用时如果队列为空它会阻塞直到有元素可用适用场景常用于处理具有优先级的任务调度事件处理等场景创建一个无界的默认按照元素的自然顺序进行排序创建一个具有指定初始容量的无界创建一个具有指定初始容量和自定义排序规则的无界插入元素如果队列已满则阻塞直到有空间可用无界队列一般不会阻塞插入移除并返回队头元素优先级最高的元素如果队列为空则阻塞直到有元素可用尝试插入元素如果队列未满则返回否则返回非阻塞尝试在指定时间内插入元素如果队列未满则返回否则返回带超时尝试在指定时间内移除并返回队头元素如果队列为空则阻塞指定时间尝试移除并返回队头元素优先级最高的元素如果队列为空则返回非阻塞返回队头元素但不移除它如果队列为空则返回判断队列是否为空返回队列当前元素的数量清空队列中的所有元素移除队列中的所有元素并将其添加到给定的集合中延迟队列其元素只能在指定的延迟时间到期后才能被取出队列中的每个元素都需要实现接口并指定一个延迟时间阻塞操作它是一个线程安全的阻塞队列当尝试取出队列中的元素时如果元素尚未到期调用者会被阻塞直到有元素到期或者队列为空无界队列可以不断插入元素队列的容量仅受限于系统内存当元素没有到期时不会被移除直到到期时间达到适用场景适用于任务调度和延时事件处理的场景例如处理定时任务或处理延迟消息创建一个新的无界队列元素按延迟时间进行排序将元素插入队列元素的延迟时间由的方法指定移除并返回队头元素只有当队头元素的延迟时间已到时才会返回如果队列为空或元素尚未到期则阻塞尝试在指定时间内移除并返回队头元素如果队列为空或队头元素尚未到期则阻塞指定时间尝试移除并返回队头元素如果队列为空或队头元素尚未到期则返回非阻塞返回队头元素但不移除它如果队列为空或队头元素尚未到期则返回判断队列是否为空返回队列当前元素的数量清空队列中的所有元素并发工具计数器锁允许一个或多个线程直到其他线程都完成工作后才会继续执行需求有个计算任务需要先将这些任务的结果全部计算出来每个任务的执行时间未知当所有任务结束之后立即整合统计最终结果示例创建一个初始值为的计数器锁子任务执行完成每执行一次计数器都会开始等待所有的线程完成当计数器为时恢复运行所有子任务都完成注意这个计数器只能使用一次用完只能重新创一个没有重置的说法子任务执行完成子任务执行完成子任务执行完成子任务执行完成子任务执行完成子任务执行完成子任务执行完成子任务执行完成子任务执行完成子任务执行完成子任务执行完成子任务执行完成子任务执行完成子任务执行完成子任务执行完成子任务执行完成子任务执行完成子任务执行完成子任务执行完成子任务执行完成所有子任务都完成进程已结束退出代码为循环屏障允许一组线程互相等待直到所有线程都到达某个公共的同步点后才会继续执行需求假如现在游戏房间为空但是游戏开始需要人所以必须集齐人到来之后才能开始游戏并且保证游戏开始时所有玩家都是同时进入示例创建一个初始值为的循环屏障飞机马上就要起飞了各位特种兵请准备人等够之后执行的任务玩家进入房间进行等待调用方法进行等待直到等待的线程足够多为止可循环玩家进入游戏开始游戏玩家进入房间进行等待玩家进入房间进行等待玩家进入房间进行等待玩家进入房间进行等待玩家进入房间进行等待飞机马上就要起飞了各位特种兵请准备玩家进入游戏玩家进入游戏玩家进入游戏玩家进入游戏玩家进入游戏玩家进入房间进行等待玩家进入房间进行等待玩家进入房间进行等待玩家进入房间进行等待玩家进入房间进行等待飞机马上就要起飞了各位特种兵请准备玩家进入游戏玩家进入游戏玩家进入游戏玩家进入游戏玩家进入游戏进程已结束退出代码为信号量用于控制多个线程对共享资源的访问它通过维护一个许可计数来管理并发访问可以被用来限制同时访问特定资源的线程数从而避免资源竞争和过度的线程争用需求现在有个线程同时进行任务任务要求是执行某个方法但是这个方法最多同时只能由个线程执行示例信号量为个线程任务类获取信号量线程开始执行任务获取到信号量开始执行任务执行完毕释放信号量线程开始执行任务线程开始执行任务线程开始执行任务线程开始执行任务线程开始执行任务线程开始执行任务线程开始执行任务线程开始执行任务线程开始执行任务线程开始执行任务进程已结束退出代码为剩余许可证数量是否存在线程等待许可证等待许可证线程数量直接回收掉剩余的许可证数据交换用于线程之间的数据交换示例收到主线程传递的交换数据收到子线程传递的交换数据收到主线程传递的交换数据收到子线程传递的交换数据进程已结束退出代码为框架在时出现了一个新的框架用于并行执行任务它的目的是为了把大型任务拆分为多个小任务最后汇总多个小任务的结果得到整大任务的结果并且这些小任务都是同时在进行大大提高运算效率就是拆分就是合并它不仅仅只是拆分任务并使用多线程而且还可以利用工作窃取算法提高线程的利用率工作窃取算法指某个线程从其他队列里窃取任务来执行一个大任务分割为若干个互不依赖的子任务为了减少线程间的竞争把这些子任务分别放到不同的队列里并为每个队列创建一个单独的线程来执行队列里的任务线程和队列一一对应但是有的线程会先把自己队列里的任务干完而其他线程对应的队列里还有任务待处理干完活的线程与其等着不如帮其他线程干活于是它就去其他线程的队列里窃取一个任务来执行需求计算的和示例求和结果继承这样才可以作为一个任务泛型就是计算结果类型范围每个任务最多计算个数的和大于继续拆分继续划分子任务执行继续划分子任务执行合并结果返回小于就可以开始算了开始计算的值开始计算的值开始计算的值开始计算的值开始计算的值开始计算的值开始计算的值开始计算的值开始计算的值求和结果进程已结束退出代码为线程池将已创建的线程复用利用池化技术就像数据库连接池一样然后反复地使用这些线程而不对它们进行销毁线程池的使用构造方法参数核心线程池大小每向线程池提交一个多线程任务时都会创建一个新的核心线程无论是否存在其他空闲线程直到到达核心线程池大小为止之后会尝试复用线程资源最大线程池大小当目前线程池中所有的线程都处于运行状态并且等待队列已满那么就会直接尝试继续创建新的非核心线程运行但是不能超过最大线程池大小线程最大空闲时间当一个非核心线程空闲超过一定时间会自动销毁线程最大空闲时间的时间单位线程等待队列当线程池中核心线程数已满时就会将任务暂时存到等待队列中直到有线程资源可用为止线程创建工厂可以自定义线程池中线程的创建过程拒绝策略当等待队列和线程池都没有空间时来了个新的多线程任务这时就会根据当前设定的拒绝策略进行处理拒绝策略含义直接抛异常默认直接让提交任务的线程运行这个任务丢弃队列中最近的一个任务替换为当前任务什么也不用做线程池执行任务的特性密集型主要是执行计算任务线程池大小一般配置为的核心数密集型主要是进行操作线程池大小一般配置为的核心数的倍示例个核心线程最大线程数为个最大空闲时间为秒这里使用容量为的阻塞队列开始个任务开始执行已结束线程池中线程数量查看当前线程池中的线程数量等到超过空闲时间线程池中线程数量使用完线程池记得关闭不然程序不会结束它会取消所有等待中的任务以及试图中断正在执行的任务关闭后无法再提交任务一律拒绝同样可以关闭但是会执行完等待队列中的任务再关闭开始执行开始执行开始执行开始执行已结束已结束已结束开始执行开始执行已结束线程池中线程数量已结束已结束线程池中线程数量进程已结束退出代码为除了使用官方提供的种拒绝策略之外还可以使用自定义的策略实现一个就在当前线程执行的策略直接运行还可以自行决定如何创建新的线程我的自定义线程开始执行我的自定义线程开始执行我的自定义线程开始执行我的自定义线程开始执行我的自定义线程开始执行进程已结束退出代码为如果任务在运行过程中出现异常了再次提交新的任务执行的线程是一个新的线程了最大容量和核心容量锁定为我是异常抛出异常我是异常进程已结束退出代码为可以使用工具类来快速创建线程池值创建一个固定容量的线程池创建一个只有一个线程的线程池会根据需要无限制创建新线程的线程池执行带返回值的任务使用提交任务会返回一个对象如果任务未完成会被阻塞任务完成返回执行结果的返回值任务是否执行完成任务是否被取消取消任务任务是否被取消任务是否执行完成任务是否被取消进程已结束退出代码为执行定时任务之后可以使用来提交定时任务它继承自并且所有的构造方法都必须要求最大线程池容量为并且都是采用的作为等待队列核心线程数为计划在秒后执行计划在秒后执行之后每隔一秒钟执行一次线程池实现原理字段用于同时保存线程池运行状态和线程数量它是通过拆分个位来保存数据的前位保存状态后位保存工作线程数量位线程数量位计算得出最大容量接收新任务并等待执行队列中的任务不接收新任务但是依然等待执行队列中的任务不接收新任务也不执行队列中的任务并且还要中断正在执行中的任务所有的任务都已结束线程数量为即将完全关闭完全关闭方法取运行状态取线程数量执行任务指定的阻塞队列如果任务为直接抛出空指针异常获取的值判断工作线程数量是否小于核心线程数直接加新的线程执行即可如果线程添加失败有可能其他线程也在对线程池进行操作那就更新一下的值如果当前线程池是运行状态那就向阻塞队列中添加一个新的等待任务再次获取的值这里是再次确认当前线程池是否关闭如果添加等待任务后线程池关闭了那就把刚刚加进去任务的又拿出来然后直接拒绝当前任务的提交会根据我们的拒绝策略决定如何进行拒绝操作如果这个时候线程池依然在运行状态那么就检查一下当前工作线程数是否为如果是那就直接添加新线程执行添加一个新的非核心线程但是注意没添加任务这种情况要么就是线程池没有运行要么就是队列满了按照之前的规则核心线程数已满且队列已满那么会直接添加新的非核心线程但是如果已经添加到最大数量这里肯定是会失败的拒绝标签获取值解析当前的运行状态判断线程池是否处于非运行状态如果不是运行状态判断线程是状态并且任务不为等待队列不为空只要有其中一者不满足直接返回添加失败解析当前的工作线程数量判断一下还装得下不如果装得下看看是核心线程还是非核心线程如果是核心线程不能大于核心线程数的限制如果是非核心线程不能大于最大线程数限制自增线程计数如果增加成功任务完成直接跳出继续直接跳出最外层循环如果失败更新一下的值如果失败的原因是因为线程池状态和一开始的不一样了那么就重新从外层循环再来一次直接从最外层循环继续如果是其他原因导致的失败那只可能是其他线程同时在自增所以重新再来一次内层循环线程计数自增完了接着就是添加新的工作线程了工作线程是否已启动工作线程是否已添加暂时理解为工作线程创建新的工作线程传入提交的任务到工作线程中封装的对象加锁获取当前线程的运行状态只有当前线程池是正在运行状态或是状态且为空那么就继续检查一下线程是否正在运行状态如果是那肯定是不能运行这个任务的直接将新创建的丢进集合中查看当前的大小记录线程池运行以来历史上的最多线程数工作线程已添加解锁启动线程工作线程已启动如果线程在上面的启动过程中失败了将移出并将计数器最后如果线程池是终止状态会尝试加速终止线程池返回是否成功启动主线程要执行的第一个任务记录这个线程完成了多少个任务执行之前不让中断将的设定为通过预定义或是自定义的线程工厂创建线程真正开始执行任务是否已加锁获取当前线程取出要执行的任务然后把中的任务设定为因为一开始为这里是通过操作将其修改回只有大于等于才能响应中断只要任务不为或是任务为空但是可以从等待队列中取出任务不为空那么就开始执行这个任务注意这里是无限循环也就是说如果当前没有任务了那么会在方法中卡住因为要从阻塞队列中等着取任务对当前加锁这里其实并不是防其他线程而是在时保护此任务的运行由于线程池在状态及以上会禁止新线程加入并且中断正在进行的线程只要线程池是及以上的状态那肯定是不能开始新任务的线程是否已经被打上中断标记并且线程一定是及以上再次确保线程没有被打上中断标记打中断标记开始之前的准备工作这里暂时没有实现开始执行任务执行之后的工作也没实现任务已完成不需要了任务完成数解锁如果能走到这一步那说明上面的循环肯定是跳出了也就是说这个可以丢弃了所以这里会直接将从里删除掉从阻塞队列里获取任务获取解析线程池运行状态判断是不是没有必要再执行等待队列中的任务了也就是处于关闭线程池的状态了直接减少一个工作线程数量返回这样上面的就直接结束了下同如果线程池运行正常那就获取当前的工作线程数量如果线程数大于核心线程数或是允许核心线程等待超时那么就标记为可超时的超时或在运行期间被修改了并且线程数大于或等待队列为空那也是不能获取到任务的如果减少工作线程成功否则开启下一轮循环如果可超时那么最多等到超时时间如果不可超时那就一直等着拿任务如果成功拿到任务返回否则就是超时了下一轮循环将直接返回发生中断异常重置超时标记开下一轮循环吧关闭线程池关闭线程池但是会继续将等待队列中的线程执行完成后再关闭加锁判断是否有权限终止将线程池运行状态改为状态让闲着的线程比如正在等新的任务中断但是并不会影响正在运行的线程给提供的钩子方法就是等去实现的当前类没有实现解锁最后尝试终止线程池获取是否大于等于指定的状态设置的值结束加锁拿到中的线程先判断一下线程是不是没有被中断然后尝试加锁但是通过前面的源代码得知开始之后是让加了锁的所以如果线程还在执行任务那么这里肯定会如果走到这里那么说明线程肯定是一个闲着的线程直接给中断吧解锁如果只针对一个那么就结束循环解锁关闭线程池不仅不允许新的任务到来也不会再执行等待队列的线程而且会终止正在执行的线程加锁直接设定为状态直接中断所有工作线程取出仍处于阻塞队列中的线程解锁最后返回还没开始的任务加锁遍历所有无差别对待一律加中断标记解锁完完全全终止掉一个线程池获取一下的值只要是正在运行或是线程池基本上关闭了或是处于状态且工作队列不为空那么这时还不能关闭线程池走到这里要么处于状态且等待队列为空或是状态如果工作线程数不是这里也会中断空闲状态下的线程这里最多只中断一个空闲线程然后返回走到这里工作线程也为空了可以终止线程池了先将状态设定为表示基本终止正在做最后的操作终止暂时没有实现最后将状态设定为表示线程池结束了如果有线程调用了方法会等待当前线程池终止到这里差不多就可以唤醒了如果失败会直接进下一轮循环重新判断',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-15 17:51:59',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://gitee.com/kokoachino/picture-bed/raw/master/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/head.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">星开祈灵的个人博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="http://8.138.214.176:5174/%E9%A1%B9%E7%9B%AE%E5%9B%BE%E5%BA%8A/%E6%98%9F%E5%BC%80%E7%A5%88%E7%81%B5%E7%99%BE%E5%AE%9D%E7%AE%B1%20%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3-29.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="http://8.138.214.176:5174/%E9%A1%B9%E7%9B%AE%E5%9B%BE%E5%BA%8A/%E6%98%9F%E5%BC%80%E7%A5%88%E7%81%B5%E7%99%BE%E5%AE%9D%E7%AE%B1%20%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3-29.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/API/" style="font-size: 1.05rem;">API<sup>1</sup></a><a href="/tags/CSS/" style="font-size: 1.05rem;">CSS<sup>1</sup></a><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>1</sup></a><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>9</sup></a><a href="/tags/Lambda/" style="font-size: 1.05rem;">Lambda<sup>1</sup></a><a href="/tags/Matlab/" style="font-size: 1.05rem;">Matlab<sup>1</sup></a><a href="/tags/MySQL/" style="font-size: 1.05rem;">MySQL<sup>1</sup></a><a href="/tags/Optional/" style="font-size: 1.05rem;">Optional<sup>1</sup></a><a href="/tags/Stream-%E6%B5%81/" style="font-size: 1.05rem;">Stream 流<sup>1</sup></a><a href="/tags/Web/" style="font-size: 1.05rem;">Web<sup>6</sup></a><a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 1.05rem;">事务<sup>4</sup></a><a href="/tags/%E5%87%BD%E6%95%B0/" style="font-size: 1.05rem;">函数<sup>4</sup></a><a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/" style="font-size: 1.05rem;">函数式接口<sup>1</sup></a><a href="/tags/%E5%88%86%E6%94%AF/" style="font-size: 1.05rem;">分支<sup>1</sup></a><a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 1.05rem;">反射<sup>1</sup></a><a href="/tags/%E5%91%BD%E4%BB%A4/" style="font-size: 1.05rem;">命令<sup>2</sup></a><a href="/tags/%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/" style="font-size: 1.05rem;">图像绘制<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>1</sup></a><a href="/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/" style="font-size: 1.05rem;">存储过程<sup>1</sup></a><a href="/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/" style="font-size: 1.05rem;">定时器<sup>2</sup></a><a href="/tags/%E5%B1%9E%E6%80%A7/" style="font-size: 1.05rem;">属性<sup>2</sup></a><a href="/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8/" style="font-size: 1.05rem;">异常处理器<sup>1</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 1.05rem;">数学<sup>2</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.05rem;">数据库<sup>2</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" style="font-size: 1.05rem;">数据类型<sup>4</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97/" style="font-size: 1.05rem;">数据统计与计算<sup>1</sup></a><a href="/tags/%E6%96%87%E4%BB%B6/" style="font-size: 1.05rem;">文件<sup>1</sup></a><a href="/tags/%E6%96%B0%E7%89%B9%E6%80%A7/" style="font-size: 1.05rem;">新特性<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/" style="font-size: 1.05rem;">正则匹配<sup>1</sup></a><a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 1.05rem;">注解<sup>5</sup></a><a href="/tags/%E6%B8%B8%E6%A0%87/" style="font-size: 1.05rem;">游标<sup>1</sup></a><a href="/tags/%E7%AC%A6%E5%8F%B7%E5%AF%B9%E8%B1%A1/" style="font-size: 1.05rem;">符号对象<sup>1</sup></a><a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 1.05rem;">索引<sup>1</sup></a><a href="/tags/%E8%A7%86%E5%9B%BE/" style="font-size: 1.05rem;">视图<sup>1</sup></a><a href="/tags/%E8%A7%A6%E5%8F%91%E5%99%A8/" style="font-size: 1.05rem;">触发器<sup>1</sup></a><a href="/tags/%E8%AF%AD%E6%B3%95/" style="font-size: 1.05rem;">语法<sup>8</sup></a><a href="/tags/%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/" style="font-size: 1.05rem;">远程仓库<sup>1</sup></a><a href="/tags/%E9%80%89%E6%8B%A9%E5%99%A8/" style="font-size: 1.05rem;">选择器<sup>1</sup></a><a href="/tags/%E9%94%81/" style="font-size: 1.05rem;">锁<sup>4</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">八月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">六月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url">后端</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Java/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Java</span></a><a class="article-meta__tags" href="/tags/%E9%94%81/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>锁</span></a><a class="article-meta__tags" href="/tags/JUC/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>JUC</span></a><a class="article-meta__tags" href="/tags/volatile/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>volatile</span></a><a class="article-meta__tags" href="/tags/AQS/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>AQS</span></a><a class="article-meta__tags" href="/tags/%E5%8E%9F%E5%AD%90%E7%B1%BB/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>原子类</span></a><a class="article-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>并发</span></a><a class="article-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>线程池</span></a></span></div></div><h1 class="post-title" itemprop="name headline">JavaJUC 多线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-11-15T16:00:00.000Z" title="发表于 2024-11-16 00:00:00">2024-11-16</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-05-15T09:51:59.888Z" title="更新于 2025-05-15 17:51:59">2025-05-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为广州"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>广州</span></div></div></div><article class="post-content" id="article-container" itemscope itemtype="https://kokoachino.github.io/2024/11/16/13%20JavaJUC%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><header><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url">后端</a><a href="/tags/Java/" tabindex="-1" itemprop="url">Java</a><a href="/tags/%E9%94%81/" tabindex="-1" itemprop="url">锁</a><a href="/tags/JUC/" tabindex="-1" itemprop="url">JUC</a><a href="/tags/volatile/" tabindex="-1" itemprop="url">volatile</a><a href="/tags/AQS/" tabindex="-1" itemprop="url">AQS</a><a href="/tags/%E5%8E%9F%E5%AD%90%E7%B1%BB/" tabindex="-1" itemprop="url">原子类</a><a href="/tags/%E5%B9%B6%E5%8F%91/" tabindex="-1" itemprop="url">并发</a><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" tabindex="-1" itemprop="url">线程池</a><h1 id="CrawlerTitle" itemprop="name headline">JavaJUC 多线程</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">星开祈灵</span><time itemprop="dateCreated datePublished" datetime="2024-11-15T16:00:00.000Z" title="发表于 2024-11-16 00:00:00">2024-11-16</time><time itemprop="dateCreated datePublished" datetime="2025-05-15T09:51:59.888Z" title="更新于 2025-05-15 17:51:59">2025-05-15</time></header><span id="more"></span>



<h1 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Main.class) &#123;</span><br><span class="line">        <span class="comment">// 同步代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步代码块的执行过程：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/13%20JavaJUC%20%E5%A4%9A%E7%BA%BF%E7%A8%8B-1.jpg"></p>
<p><code>synchronized</code>使用的锁存储在 Java 对象头中</p>
<p>每个对象内部，都有一部分空间用于存储对象头信息，包含了<code>Mark Word</code>用于存放<code>hashCode</code>和对象的锁信息</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/13%20JavaJUC%20%E5%A4%9A%E7%BA%BF%E7%A8%8B-2.jpg"></p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>在 JDK6 之前，<code>synchronized</code>一直被称为重量级锁</p>
<p>每个对象都有一个<code>monitor</code>与之关联，在 Java 虚拟机（HotSpot）中，<code>monitor</code>是由<code>ObjectMonitor</code>实现的 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ObjectMonitor</span>() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">// 记录个数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>;</span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">// 处于 wait 状态的线程，会被加入到 _WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span>;</span><br><span class="line">    _succ         = <span class="literal">NULL</span>;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span>;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span>;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span>; <span class="comment">// 处于等待锁 block 状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个等待锁的线程都会被封装成<code>ObjectWaiter</code>对象，进入到如下机制：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/13%20JavaJUC%20%E5%A4%9A%E7%BA%BF%E7%A8%8B-3.jpg"></p>
<ol>
<li><p>进入 Entry Set 等待</p>
</li>
<li><p>当线程获取到对象的<code>monitor</code>后，进入 The Owner 区域</p>
<p>并把<code>monitor</code>中的<code>owner</code>设置为当前线程，同时<code>monitor</code>中<code>count++</code></p>
</li>
<li><p>若当前线程执行完毕或调用<code>wait()</code>方法，将会释放当前持有的<code>monitor</code></p>
<p>并把<code>monitor</code>中的<code>owner</code>设置为<code>null</code>，同时<code>monitor</code>中<code>count--</code></p>
</li>
<li><p>该线程进入 WaitSet 集合中，等待被唤醒</p>
</li>
</ol>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>在 JDK1.6 时，引入了<strong>轻量级锁</strong></p>
<p>轻量级锁的目标是，在无竞争情况下，减少重量级锁产生的性能消耗</p>
<p>它的运作机制如下：</p>
<ol>
<li>在即将开始执行同步代码块中的内容时，会首先检查对象的<code>Mark Word</code>，查看锁对象是否被其他线程占用</li>
<li>如果没有任何线程占用，那么会在当前线程中所处的栈帧中建立一个名为<strong>锁记录</strong>的空间，用于复制并存储对象目前的<code>Mark Word</code>信息</li>
<li>虚拟机将使用<strong>CAS</strong>操作将对象的<code>Mark Word</code>更新为轻量级锁状态</li>
</ol>
<blockquote>
<p>CAS 是一种无锁算法，用于避免线程在操作共享资源时的互斥锁或其他锁机制，降低并发性能瓶颈</p>
<p>CAS 的操作步骤如下：</p>
<ul>
<li>线程检查内存地址的当前值是否与预期值相同</li>
<li>如果相同，则将该内存位置的值更新为新值</li>
<li>如果不同，CAS 操作将失败，并且不会改变内存中的值。线程可以重新读取内存值并重新尝试</li>
</ul>
</blockquote>
<p>如果 CAS 操作失败了的话，那么说明可能这时有其他线程已经进入这个同步代码块了</p>
<p>这时虚拟机会再次检查对象的<code>Mark Word</code>是否指向当前线程的栈帧</p>
<p>如果是，说明是当前线程已经有了这个对象的锁，这时直接进同步代码块即可</p>
<p>否则，只能将锁膨胀为重量级锁，按照重量级锁的操作执行（注意锁的膨胀是不可逆的）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/13%20JavaJUC%20%E5%A4%9A%E7%BA%BF%E7%A8%8B-4.jpg"></p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>在 JDK1.4.2 时，引入了<strong>自旋锁</strong>（JDK6 之后默认开启）</p>
<p>它不会将处于等待状态的线程挂起，而是通过无限循环的方式，不断检测是否能够获取锁</p>
<p>由于单个线程占用锁的时间非常短，所以说循环次数不会太多，可能很快就能够拿到锁并运行</p>
<p>自旋锁的等待时间是有限制的，默认情况下为<code>10</code>次。如果失败，那么会进而采用重量级锁机制</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/13%20JavaJUC%20%E5%A4%9A%E7%BA%BF%E7%A8%8B-5.jpg"></p>
<p>在 JDK6 之后，自旋锁得到了一次优化，自旋的次数限制不再是固定的，而是自适应变化的</p>
<blockquote>
<p>轻量级锁 -&gt; 失败 -&gt; 自适应自旋锁 -&gt; 失败 -&gt; 重量级锁</p>
</blockquote>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁实际上就是专门为单个线程而生的</p>
<p>当某个线程第一次获得锁时，如果接下来都没有其他线程获取此锁，那么持有锁的线程将不再需要进行同步操作</p>
<p>偏向锁也会通过 CAS 操作记录线程的 ID，如果一直都是同一个线程获取此锁，那么完全没有必要在进行额外的 CAS 操作</p>
<p>当然，如果有其他线程来抢了，那么偏向锁会根据当前状态，决定是否要恢复到<strong>未锁定</strong>或是膨胀为<strong>轻量级锁</strong></p>
<blockquote>
<p>可以添加<code>-XX:+UseBiased</code>参数，来开启偏向锁</p>
</blockquote>
<p>值得注意的是，如果对象通过调用<code>hashCode()</code>方法计算过对象的一致性哈希值，那么它是不支持偏向锁的，会直接进入到轻量级锁状态</p>
<p>因为偏向锁的<code>Mark Word</code>数据结构无法保存哈希值</p>
<p>如果对象已经是偏向锁状态，再去调用<code>hashCode()</code>方法，那么会直接将锁升级为重量级锁</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/13%20JavaJUC%20%E5%A4%9A%E7%BA%BF%E7%A8%8B-6.jpg"></p>
<p>所以，最终锁的等级为：</p>
<blockquote>
<p>未锁定 &lt; 偏向锁 &lt; 轻量级锁 &lt; 重量级锁</p>
</blockquote>
<h3 id="锁消除和锁粗化"><a href="#锁消除和锁粗化" class="headerlink" title="锁消除和锁粗化"></a>锁消除和锁粗化</h3><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>锁消除是 JVM 在编译时的一种优化技术，旨在消除不必要的锁</p>
<p>当 JVM 检测到某个对象的锁只在单线程中被使用，且不会在多个线程间共享时，它会自动消除锁，避免不必要的同步开销</p>
<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>锁粗化是将多个相近的锁操作合并成一个更大的锁范围</p>
<p>这样做可以减少频繁的锁操作，降低上下文切换和加锁释放的开销，尤其是在多个连续的同步操作中</p>
<h1 id="JMM-内存模型"><a href="#JMM-内存模型" class="headerlink" title="JMM 内存模型"></a>JMM 内存模型</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/13%20JavaJUC%20%E5%A4%9A%E7%BA%BF%E7%A8%8B-7.jpg"></p>
<p><strong>JMM 内存模型</strong>规定如下：</p>
<ul>
<li><p>所有的变量全部存储在主内存</p>
</li>
<li><p>每条线程有着自己的工作内存（类比 CPU 的高速缓存）</p>
<p>线程对变量（不包括局部变量）的所有操作，必须在工作内存中进行，不能直接操作主内存中的数据</p>
</li>
<li><p>不同线程之间的工作内存相互隔离</p>
<p>如果需要在线程之间传递内容，只能通过主内存完成，无法直接访问对方的工作内存</p>
</li>
</ul>
<p>也就是说，每一条线程如果要操作主内存中的数据，那么得先拷贝到自己的工作内存中，并对工作内存中数据的副本进行操作</p>
<p>操作完成之后，也需要从工作副本中将结果拷贝回主内存中</p>
<p><strong>缓存不一致示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) i++;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) i++;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(i); <span class="comment">// 149926（不符合预期）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上自增操作并不是由一条指令完成的</p>
<p>包括变量<code>i</code>的获取、修改、保存，都是被拆分为一个一个的操作完成的</p>
<p>那么这个时候就有可能出现在修改完保存之前，另一条线程也保存了，但是当前线程是毫不知情的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/13%20JavaJUC%20%E5%A4%9A%E7%BA%BF%E7%A8%8B-8.jpg"></p>
<p>这可以通过添加<code>synchronized</code>关键字，使其变为同步代码块解决</p>
<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>在编译或执行时，为了优化程序的执行效率，编译器或处理器常常会对指令进行重排序，有以下情况：</p>
<ol>
<li>编译器重排序：Java 编译器通过对 Java 代码语义的理解，根据优化规则对代码指令进行重排序</li>
<li>机器指令级别的重排序：现代处理器很高级，能够自主判断和变更机器指令的执行顺序</li>
</ol>
<p>指令重排序能够在不改变结果（单线程）的情况下，优化程序的运行效率，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    System.out.println(a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实可以交换第一行和第二行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    System.out.println(a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使发生交换，但是程序最后的运行结果是不会变的</p>
<p>虽然单线程下指令重排确实可以起到一定程度的优化作用，但是在多线程下，似乎会导致一些问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(b == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            a = <span class="number">1</span>;</span><br><span class="line">            b = <span class="number">1</span>;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码，在正常情况下，是不可能输出<code>A</code>的</p>
<p>因为只要<code>b == 1</code>，那么肯定有<code>a == 1</code>，因为<code>a</code>是在<code>b</code>之前完成的赋值</p>
<p>但是，如果进行了重排序，那么就有可能，<code>a</code>和<code>b</code>的赋值发生了交换</p>
<p><code>b</code>先被赋值为<code>1</code>，而恰巧这个时候，线程<code>1</code>已经开始判定<code>b == 1</code>了，这时<code>a</code>还没来得及被赋值为<code>1</code>，可能线程<code>1</code>就已经走到打印那里去了</p>
<p>所以，是有可能输出<code>A</code>的</p>
<h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h3><p>多线程编程中的三个重要概念：</p>
<ul>
<li><strong>原子性</strong>：一个操作要么完全成功，要么完全失败，不能被中断</li>
<li><strong>可见性</strong>：一个线程对共享变量的修改能立即被其他线程看到</li>
<li><strong>有序性</strong>：确保指令执行的顺序性</li>
</ul>
<p><strong>可见性示例</strong>：                   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (a == <span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程结束！&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;修改 a 的值...&quot;</span>);</span><br><span class="line">        a = <span class="number">1</span>; <span class="comment">// 按照正常的逻辑来说，a 的值被修改后，那么另一个线程将不再循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然主线程中修改了<code>a</code>的值，但是另一个线程并不知道<code>a</code>的值发生了改变，所以循环中依然是使用旧值在进行判断</p>
<p>因此，普通变量是不具有可见性的</p>
<p><strong>解决方案</strong>：</p>
<p>添加<code>volatile</code>关键字，以保证变量的可见性</p>
<p>当写入一个<code>volatile</code>变量时，JMM 会确保该线程将本地内存中的变量刷新到主内存中</p>
<p>同时其他线程中的相同<code>volatile</code>变量的缓存会失效，确保其他线程能看到最新的值               </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (a == <span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程结束！&quot;</span>); <span class="comment">// 线程正常结束</span></span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;修改 a 的值...&quot;</span>);</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然说<code>volatile</code>能够保证可见性，但是不能保证原子性</p>
<p>要解决之前的<code>i++</code>的问题，目前还是只能使用加锁来完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) a++;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(a); <span class="comment">// 16402</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一个功能就是<code>volatile</code>会禁止指令重排</p>
<p>也就是说，如果操作的是一个<code>volatile</code>变量，它将不会出现重排序的情况</p>
<p>如果使用<code>volatile</code>修饰共享变量，在编译时，会在指令序列中插入<strong>内存屏障</strong>来禁止特定类型的处理器重排序</p>
<blockquote>
<p>内存屏障又称内存栅栏，是一个 CPU 指令，它的作用有两个：</p>
<ol>
<li>保证特定操作的顺序</li>
<li>保证某些变量的内存可见性</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/13%20JavaJUC%20%E5%A4%9A%E7%BA%BF%E7%A8%8B-9.jpg"></p>
<table>
<thead>
<tr>
<th align="center">屏障类型</th>
<th align="center">指令示例</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LoadLoad</td>
<td align="center">Load1;LoadLoad;Load2</td>
<td align="center">读操作1 -&gt; 读操作2</td>
</tr>
<tr>
<td align="center">StoreStore</td>
<td align="center">Store1;StoreStore;Store2</td>
<td align="center">写操作1 -&gt; 写操作2</td>
</tr>
<tr>
<td align="center">LoadStore</td>
<td align="center">Load1;LoadStore;Store2</td>
<td align="center">读操作1 -&gt; 写操作2</td>
</tr>
<tr>
<td align="center">StoreLoad</td>
<td align="center">Store1;StoreLoad;Load2</td>
<td align="center">写操作1 -&gt; 读操作2</td>
</tr>
</tbody></table>
</blockquote>
<p>所以<code>volatile</code>能够保证：之前的指令一定全部执行，之后的指令一定都没有执行，并且前面语句的结果对后面的语句都可见</p>
<h3 id="happens-before-原则"><a href="#happens-before-原则" class="headerlink" title="happens-before 原则"></a>happens-before 原则</h3><p><strong>happens-before 原则</strong>（先行发生原则）是 JMM 中非常重要的一个概念，它定义了多线程程序中操作的执行顺序</p>
<p>简单来说，它规定了当一个操作在另一个操作之前执行时，前一个操作的结果对于后一个操作是可见的</p>
<p>具体来说，<strong>happens-before 原则</strong>用于回答以下问题：</p>
<blockquote>
<p>如果线程 A 对某个共享变量进行修改，线程 B 在某个时刻读取该变量，线程 B 能否看到线程 A 修改后的值？</p>
</blockquote>
<h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h4><ul>
<li><strong>happens-before</strong> 定义了操作之间的顺序关系，确保先执行的操作的结果对后执行的操作可见</li>
<li>如果操作 A <strong>happens-before</strong> 操作 B，那么线程 B 必定能够看到线程 A 对共享变量的修改</li>
<li>它不仅限于内存可见性，还涉及到程序执行的顺序性</li>
</ul>
<h4 id="常见规则"><a href="#常见规则" class="headerlink" title="常见规则"></a>常见规则</h4><ol>
<li><p><strong>程序顺序规则</strong></p>
<p>在一个线程中，按照程序中代码的顺序，先执行的操作 <strong>happens-before</strong> 后执行的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x + <span class="number">5</span>; <span class="comment">// 这里 y 的计算 happens-before x 的值被读取</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>监视器锁规则</strong></p>
<p>对一个锁的解锁操作 <strong>happens-before</strong> 后续对同一个锁的加锁操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="comment">// 写操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里的解锁 happens-before 后续线程对同一锁的加锁操作</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="comment">// 读操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>volatile 变量规则</strong></p>
<p>对<code>volatile</code>变量的写操作 <strong>happens-before</strong> 后续对该<code>volatile</code>变量的读操作</p>
<p>换句话说，如果线程 A 写入一个<code>volatile</code>变量，线程 B 读取该<code>volatile</code>变量，线程 B 能看到线程 A 修改后的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">flag = <span class="literal">true</span>; <span class="comment">// 线程 A 写操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程 B 读操作</span></span><br><span class="line"><span class="keyword">if</span> (flag) &#123; <span class="comment">// 线程 B 看到线程 A 写入的 flag 的最新值</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程启动规则</strong></p>
<p>在启动一个新线程时，线程 A 的启动操作 <strong>happens-before</strong> 线程 A 中的任何操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 线程 t 的任务</span></span><br><span class="line">&#125;);</span><br><span class="line">t.start(); <span class="comment">// 线程 t 的 start() happens-before 线程 t 中的任何操作</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程终止规则</strong></p>
<p>线程的<code>join()</code>操作 <strong>happens-before</strong> 线程终止后的操作</p>
<p>即调用<code>join()</code>方法的线程，会等待被调用线程结束，然后继续执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.join(); <span class="comment">// 线程 t 的结束 happens-before 线程 t 之后的操作</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li><p><strong>内存可见性</strong>：确保先发生的操作对后发生的操作是可见的</p>
</li>
<li><p><strong>避免乱序执行</strong>：通过指定操作顺序，避免 JVM 或硬件在优化时造成不必要的乱序执行</p>
</li>
<li><p><strong>保障正确性</strong>：帮助确保程序的正确性，特别是在多线程并发场景下，避免了出现竞态条件和数据不一致等问题</p>
</li>
</ul>
<h1 id="锁框架"><a href="#锁框架" class="headerlink" title="锁框架"></a>锁框架</h1><p>在 JDK 5 之后，并发包中新增了<code>Lock</code>接口（以及相关实现类）用来实现锁功能</p>
<p><code>Lock</code>接口提供了与<code>synchronized</code>关键字类似的同步功能，但需要在使用时手动获取锁和释放锁</p>
<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><blockquote>
<p>提供了一种比传统的<code>synchronized</code>关键字更灵活、功能更强大的锁机制</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>; <span class="comment">// 获取锁，若锁被占用，则会阻塞直到获取锁</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException; <span class="comment">// 获取锁，但可以响应中断</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>; <span class="comment">// 尝试获取锁，如果获取不到立即返回 false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException; <span class="comment">// 尝试获取锁，最多等待指定的时间，时间单位由参数指定</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>; <span class="comment">// 释放锁</span></span><br><span class="line">    Condition <span class="title function_">newCondition</span><span class="params">()</span>; <span class="comment">// 返回一个新的 Condition 实例，用于实现线程间的等待和通知</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">testLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">// 可重入锁 ReentrantLock 类是 Lock 类的一个实现</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">action</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;</span><br><span class="line">                testLock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">                i++;</span><br><span class="line">                testLock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(action).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(action).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(i); <span class="comment">// 200000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><blockquote>
<p>提供比传统的<code>Object</code>类中的<code>wait()</code>、<code>notify()</code>和<code>notifyAll()</code>方法更加灵活和强大的线程间通信机制</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException; <span class="comment">// 与对象的 wait 方法类似，进入等待状态，并在被 signal 或 signalAll 唤醒后继续执行，同时等待状态下可以响应中断</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>; <span class="comment">// 同上，但不会响应中断</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException; <span class="comment">// 等待指定纳秒时间，如果被唤醒则返回剩余时间，否则超时返回 0 或负值，可以响应中断</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException; <span class="comment">// 等待指定时间（时间单位可指定），如果在指定时间内被唤醒则返回 true，否则返回 false，可以响应中断</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException; <span class="comment">// 等待直到指定的时间点，如果在指定时间前被唤醒返回 true，否则返回 false，可以响应中断</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span>; <span class="comment">// 唤醒一个在等待状态中的线程，唤醒后线程需要重新获得锁才能继续执行</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span>; <span class="comment">// 唤醒所有在等待状态中的线程，唤醒的线程需重新获得锁才能继续执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">testLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> testLock.newCondition();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            testLock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 1 进入等待状态！&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                condition.await(); <span class="comment">// 进入等待状态</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 1 等待结束！&quot;</span>);</span><br><span class="line">            testLock.unlock();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            testLock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 2 开始唤醒其他等待线程&quot;</span>);</span><br><span class="line">            condition.signal(); <span class="comment">// 唤醒线程 1，但是此时线程 1 还必须要拿到锁才能继续运行</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程 2 结束&quot;</span>);</span><br><span class="line">            testLock.unlock(); <span class="comment">// 这里释放锁之后，线程 1 就可以拿到锁继续运行了</span></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程 1 进入等待状态！</span><br><span class="line">线程 2 开始唤醒其他等待线程</span><br><span class="line">线程 2 结束</span><br><span class="line">线程 1 等待结束！</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 0</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">testLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> testLock.newCondition();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            testLock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 1 进入等待状态！&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                testLock.newCondition().await(); <span class="comment">// 进入等待状态</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 1 等待结束！&quot;</span>);</span><br><span class="line">            testLock.unlock();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            testLock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 2 开始唤醒其他等待线程&quot;</span>);</span><br><span class="line">            testLock.newCondition().signal(); <span class="comment">// 与线程 1 使用的是不同的 Condition 对象，所以不能唤醒线程 1</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程 2 结束&quot;</span>);</span><br><span class="line">            testLock.unlock(); <span class="comment">// 这里释放锁之后，线程 1 还是在阻塞状态</span></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">线程 1 进入等待状态！</span><br><span class="line">线程 2 开始唤醒其他等待线程</span><br><span class="line">线程 2 结束</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 130</span><br></pre></td></tr></table></figure>

<p>同一把锁内是可以存在多个<code>Condition</code>对象的</p>
<p>只有对同一个<code>Condition</code>对象进行等待和唤醒操作才会有效，而不同的<code>Condition</code>对象是分开计算的</p>
<h2 id="TimeUnit"><a href="#TimeUnit" class="headerlink" title="TimeUnit"></a>TimeUnit</h2><blockquote>
<p>提供了一些便捷的方法来进行时间的转换和管理</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>NANOSECONDS</code></td>
<td align="center">纳秒</td>
</tr>
<tr>
<td align="center"><code>MICROSECONDS</code></td>
<td align="center">微秒</td>
</tr>
<tr>
<td align="center"><code>MILLISECONDS</code></td>
<td align="center">毫秒</td>
</tr>
<tr>
<td align="center"><code>SECONDS</code></td>
<td align="center">秒</td>
</tr>
<tr>
<td align="center"><code>MINUTES</code></td>
<td align="center">分钟</td>
</tr>
<tr>
<td align="center"><code>HOURS</code></td>
<td align="center">小时</td>
</tr>
<tr>
<td align="center"><code>DAYS</code></td>
<td align="center">天</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>toNanos(long duration)</code></td>
<td align="center">将给定时间单位转换为纳秒</td>
</tr>
<tr>
<td align="center"><code>toMicros(long duration)</code></td>
<td align="center">将给定时间单位转换为微秒</td>
</tr>
<tr>
<td align="center"><code>toMillis(long duration)</code></td>
<td align="center">将给定时间单位转换为毫秒</td>
</tr>
<tr>
<td align="center"><code>toSeconds(long duration)</code></td>
<td align="center">将给定时间单位转换为秒</td>
</tr>
<tr>
<td align="center"><code>toMinutes(long duration)</code></td>
<td align="center">将给定时间单位转换为分钟</td>
</tr>
<tr>
<td align="center"><code>toHours(long duration)</code></td>
<td align="center">将给定时间单位转换为小时</td>
</tr>
<tr>
<td align="center"><code>toDays(long duration)</code></td>
<td align="center">将给定时间单位转换为天</td>
</tr>
<tr>
<td align="center"><code>convert(long sourceDuration, TimeUnit sourceUnit)</code></td>
<td align="center">将给定的时间单位<code>sourceUnit</code>转换为当前时间单位</td>
</tr>
<tr>
<td align="center"><code>sleep(long timeout)</code></td>
<td align="center">使当前线程休眠指定的时间，单位由调用的<code>TimeUnit</code>枚举值决定</td>
</tr>
</tbody></table>
<h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><blockquote>
<p>用来进行线程的挂起和唤醒操作</p>
</blockquote>
<h3 id="线程挂起"><a href="#线程挂起" class="headerlink" title="线程挂起"></a>线程挂起</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LockSupport.park(); <span class="comment">// 使当前线程挂起，直到被唤醒或中断。挂起的线程会释放持有的锁，并且会处于阻塞状态</span></span><br></pre></td></tr></table></figure>

<h3 id="线程唤醒"><a href="#线程唤醒" class="headerlink" title="线程唤醒"></a>线程唤醒</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LockSupport.unpark(线程); <span class="comment">// 唤醒指定的线程，使它从 park() 状态中恢复执行</span></span><br></pre></td></tr></table></figure>

<h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>同一个线程，可以反复进行加锁操作                 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        lock.lock();</span><br><span class="line">        lock.lock(); <span class="comment">// 连续加锁 2 次</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 2 想要获取锁&quot;</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 2 成功获取到锁&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程 1 释放了一次锁&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程 1 再次释放了一次锁&quot;</span>); <span class="comment">// 释放全部锁后，其他线程才能加锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在当前线程持有锁的情况下继续加锁不会被阻塞</p>
<p>并且，加锁几次，就必须要解锁几次，否则此线程依旧持有锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lock.getHoldCount() <span class="comment">// 当前加锁次数</span></span><br><span class="line">lock.isLocked() <span class="comment">// 是否被锁</span></span><br></pre></td></tr></table></figure>

<p>实际上，如果存在线程持有当前的锁，那么其他线程在获取锁时，是会暂时进入到等待队列的                   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock.getQueueLength() <span class="comment">// 当前锁的等待队列长度</span></span><br><span class="line">lock.hasQueuedThread(线程) <span class="comment">// 线程是否正在等待获取锁状态</span></span><br><span class="line">lock.getWaitQueueLength(condition) <span class="comment">// 查看同一个 Condition 目前有多少线程处于等待状态</span></span><br></pre></td></tr></table></figure>

<h2 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h2><p>锁分为<strong>公平锁</strong>和<strong>非公平锁</strong></p>
<ul>
<li><strong>公平锁</strong>：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁</li>
<li><strong>非公平锁</strong>：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁</li>
</ul>
<p>创建出来的可重入锁<code>ReentrantLock</code>默认是采用的非公平锁作为底层锁机制</p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>它和可重入锁不同的地方在于，可重入锁是一种<strong>排他锁</strong></p>
<p>当一个线程得到锁之后，另一个线程必须等待其释放锁，否则一律不允许获取到锁</p>
<p>读写锁维护了一个读锁和一个写锁，这两个锁的机制是不同的</p>
<ul>
<li><strong>读锁</strong>：在没有任何线程占用写锁的情况下，同一时间可以有多个线程加读锁</li>
<li><strong>写锁</strong>：在没有任何线程占用读锁的情况下，同一时间只能有一个线程加写锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span> &#123;</span><br><span class="line">    Lock <span class="title function_">readLock</span><span class="params">()</span>; <span class="comment">// 获取读锁</span></span><br><span class="line">    Lock <span class="title function_">writeLock</span><span class="params">()</span>; <span class="comment">// 获取写锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此接口有一个实现类<code>ReentrantReadWriteLock</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    lock.readLock().lock();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(lock.readLock()::lock).start(); <span class="comment">// 可以多个线程同时对读锁加锁</span></span><br><span class="line">&#125;                </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    lock.readLock().lock();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(lock.writeLock()::lock).start(); <span class="comment">// 有读锁状态下无法加写锁</span></span><br><span class="line">&#125;              </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    lock.writeLock().lock();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(lock.readLock()::lock).start(); <span class="comment">// 有写锁状态下无法加读锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ReentrantReadWriteLock</code>不仅具有读写锁的功能，还保留了可重入锁和公平&#x2F;非公平机制         </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        lock.writeLock().lock(); <span class="comment">// 同一个线程可以重复为写锁加锁</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.writeLock().lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;成功获取到写锁！&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        System.out.println(<span class="string">&quot;释放第一层锁！&quot;</span>);</span><br><span class="line">        lock.writeLock().unlock();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;释放第二层锁！&quot;</span>);</span><br><span class="line">        lock.writeLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="锁降级和锁升级"><a href="#锁降级和锁升级" class="headerlink" title="锁降级和锁升级"></a>锁降级和锁升级</h3><p><strong>锁降级</strong>：写锁降级为读锁</p>
<p>当一个线程持有写锁的情况下，虽然其他线程不能加读锁，但是线程自己是可以加读锁的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    lock.writeLock().lock();</span><br><span class="line">    lock.readLock().lock(); <span class="comment">// 添加读锁</span></span><br><span class="line">    System.out.println(<span class="string">&quot;成功加读锁！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;开始加读锁！&quot;</span>);</span><br><span class="line">            lock.readLock().lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;读锁添加成功！&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        lock.writeLock().unlock(); <span class="comment">// 在同时加了写锁和读锁的情况下，释放写锁（锁降级）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>锁升级</strong>：读锁升级为写锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        lock.writeLock().lock(); <span class="comment">// 在仅持有读锁的情况下去申请写锁，ReentrantReadWriteLock 是不支持的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;锁升级成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">进程已结束，退出代码为 130</span><br></pre></td></tr></table></figure>

<h2 id="队列同步器-AQS"><a href="#队列同步器-AQS" class="headerlink" title="队列同步器 AQS"></a>队列同步器 AQS</h2><p>公平锁和非公平锁都是继承自<code>Sync</code>，而<code>Sync</code>是继承自<code>AbstractQueuedSynchronizer</code>，简称<strong>队列同步器 AQS</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;&#125; <span class="comment">// 非公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;&#125; <span class="comment">// 公平锁</span></span><br></pre></td></tr></table></figure>

<h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p><code>AQS</code>是实现锁机制的基础，它的内部封装了包括锁的获取、释放、以及等待队列</p>
<p>一个锁（排他锁为例）的基本功能就是获取锁、释放锁</p>
<p>当锁被占用时，其他线程来争抢会进入等待队列，<code>AQS</code>已经将这些基本的功能封装完成了</p>
<p>其中等待队列是核心内容，等待队列是由双向链表数据结构实现的</p>
<p>每个等待状态下的线程都可以被封装进结点中并放入双向链表中，而对于双向链表是以队列的形式进行操作的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/13%20JavaJUC%20%E5%A4%9A%E7%BA%BF%E7%A8%8B-10.jpg"></p>
<p><code>AQS</code>中有一个<code>head</code>字段和一个<code>tail</code>字段，分别记录双向链表的头结点和尾结点</p>
<p>而之后的一系列操作都是围绕此队列来进行的</p>
<h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><p><code>AQS</code>的<code>Node</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123; <span class="comment">// 每个处于等待状态的线程都可以是一个节点，并且每个节点是有很多状态的</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(); <span class="comment">// 每个节点都可以被分为独占模式节点或是共享模式节点，分别适用于独占锁和共享锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 独占模式节点为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>; <span class="comment">// 唯一一个大于 0 的状态，表示已失效，可能是由于超时或中断，此节点被取消</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 此节点后面的节点被挂起（进入等待状态）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>; <span class="comment">// 在条件队列中的节点才是这个状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>; <span class="comment">// 传播，一般用于共享锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus; <span class="comment">// 等待状态值</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev; <span class="comment">// 双向链表中的前一个节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next; <span class="comment">// 双向链表中的下一个节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread; <span class="comment">// 每一个线程都可以被封装进一个节点进入到等待队列</span></span><br><span class="line">  </span><br><span class="line">    Node nextWaiter; <span class="comment">// 在等待队列中表示模式，条件队列中作为下一个节点的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123; <span class="comment">// 判断节点是否为共享模式</span></span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123; <span class="comment">// 获取前一个节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123; <span class="comment">// 带线程和模式的构造函数</span></span><br><span class="line">        <span class="built_in">this</span>.nextWaiter = mode; <span class="comment">// 设置节点模式</span></span><br><span class="line">        <span class="built_in">this</span>.thread = thread; <span class="comment">// 设置节点线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// 带线程和等待状态的构造函数</span></span><br><span class="line">        <span class="built_in">this</span>.waitStatus = waitStatus; <span class="comment">// 设置节点的等待状态</span></span><br><span class="line">        <span class="built_in">this</span>.thread = thread; <span class="comment">// 设置节点线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AQS</code>初始化操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe(); <span class="comment">// 直接使用 Unsafe 类进行操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> stateOffset; <span class="comment">// 记录类中属性的在内存中的偏移地址，方便 Unsafe 类直接操作内存进行赋值等</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> headOffset; <span class="comment">// 这里对应的就是 AQS 类中的 head 头结点成员字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> tailOffset; <span class="comment">// 这里对应的就是 AQS 类中的 tail 成员字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> waitStatusOffset; <span class="comment">// 这里对应的就是 Node 类中的 waitStatus 成员字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> nextOffset; <span class="comment">// 这里对应的就是 Node 类中的 next 成员字段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123; <span class="comment">// 静态代码块，在类加载的时候就会自动获取偏移地址</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stateOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;state&quot;</span>));</span><br><span class="line">        headOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;head&quot;</span>));</span><br><span class="line">        tailOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;tail&quot;</span>));</span><br><span class="line">        waitStatusOffset = unsafe.objectFieldOffset</span><br><span class="line">            (Node.class.getDeclaredField(<span class="string">&quot;waitStatus&quot;</span>));</span><br><span class="line">        nextOffset = unsafe.objectFieldOffset</span><br><span class="line">            (Node.class.getDeclaredField(<span class="string">&quot;next&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetHead</span><span class="params">(Node update)</span> &#123; <span class="comment">// 通过 CAS 操作来修改头结点</span></span><br><span class="line">    <span class="comment">// 调用的是 Unsafe 类的 compareAndSwapObject 方法，通过 CAS 算法比较对象并替换</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="built_in">this</span>, headOffset, <span class="literal">null</span>, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同上，省略部分代码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> &#123;&#125; <span class="comment">// 通过 CAS 操作来修改尾结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetWaitStatus</span><span class="params">(Node node, <span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;&#125; <span class="comment">// 通过 CAS 操作来修改 Node 的 waitStatus 状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetNext</span><span class="params">(Node node, Node expect, Node update)</span> &#123;&#125; <span class="comment">// 通过 CAS 操作来修改 Node 的 next 节点</span></span><br></pre></td></tr></table></figure>

<p><code>AQS</code>可重写方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123; <span class="comment">// 独占式获取同步状态，查看同步状态是否和参数一致，如果没有问题，那么会使用 CAS 操作设置同步状态并返回 true</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123; <span class="comment">// 独占式释放同步状态</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123; <span class="comment">// 共享式获取同步状态，返回值大于 0 表示成功，否则失败</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123; <span class="comment">// 共享式释放同步状态</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123; <span class="comment">// 是否在独占模式下被当前线程占用（锁是否被当前线程持有）</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="公平锁加锁"><a href="#公平锁加锁" class="headerlink" title="公平锁加锁"></a>公平锁加锁</h4><p><code>ReentrantLock</code>（此类是全局独占式的）中的公平锁是如何借助<code>AQS</code>实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>); <span class="comment">// 加锁操作调用了 AQS 提供的模板方法 acquire</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ReservedStackAccess</span> <span class="comment">// 保护被注解的方法，通过添加一些额外的空间，防止在多线程运行的时候出现栈溢出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <span class="comment">// 节点为独占模式 Node.EXCLUSIVE</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会调用<code>tryAcquire()</code>方法（这里是由<code>FairSync</code>类实现的）</p>
<p>如果尝试加独占锁失败（返回<code>false</code>了），说明可能这个时候有其他线程持有了此独占锁，所以当前线程得先等着</p>
<p>那么会调用<code>addWaiter()</code>方法将线程加入等待队列中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode); <span class="comment">// 创建一个新的节点，将当前线程和模式传入构造函数</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail; <span class="comment">// 获取尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred; <span class="comment">// 将新节点的前驱指向尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; <span class="comment">// 尝试通过 CAS 将尾节点设置为新节点</span></span><br><span class="line">            pred.next = node; <span class="comment">// 如果 CAS 成功，将尾节点的 next 指向新节点</span></span><br><span class="line">            <span class="keyword">return</span> node; <span class="comment">// 返回新节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node); <span class="comment">// CAS 快速入队失败时调用 enq 方法进行自旋入队</span></span><br><span class="line">    <span class="keyword">return</span> node; <span class="comment">// 返回新节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 自旋入队，进行无限循环</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; <span class="comment">// 获取当前尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// 如果尾节点为 null，说明头结点和尾结点都还没有初始化</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>())) <span class="comment">// 初始化头结点和尾结点</span></span><br><span class="line">                tail = head; <span class="comment">// 将尾节点指向头节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t; <span class="comment">// 将新节点的前驱指向当前尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123; <span class="comment">// 尝试通过 CAS 将尾节点设置为新节点</span></span><br><span class="line">                t.next = node; <span class="comment">// 如果 CAS 成功，将当前尾节点的 next 指向新节点</span></span><br><span class="line">                <span class="keyword">return</span> t; <span class="comment">// 返回当前尾节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>addWaiter()</code>会返回已经加入的节点</p>
<p><code>acquireQueued()</code>在得到返回的节点时，也会进入自旋状态，等待唤醒（也就是开始进入到拿锁的环节了）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环，直到获取锁成功或出现错误</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor(); <span class="comment">// 获取当前节点的前驱节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 可以看到当此节点位于队首 (node.prev == head) 时，会再次调用 tryAcquire 方法获取锁，如果获取成功，会返回此过程中是否被中断的值</span></span><br><span class="line">                setHead(node); <span class="comment">// 新的头结点设置为当前节点</span></span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// 原有的头结点没有存在的意义了</span></span><br><span class="line">                failed = <span class="literal">false</span>; <span class="comment">// 获取锁成功，标志 failed 设为 false</span></span><br><span class="line">                <span class="keyword">return</span> interrupted; <span class="comment">// 直接返回等待过程中是否被中断</span></span><br><span class="line">            &#125;	</span><br><span class="line">            <span class="comment">// 依然没获取成功，继续进行自旋</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">// 将当前节点的前驱节点等待状态设置为 SIGNAL，如果失败将直接开启下一轮循环，直到成功为止，如果成功接着往下</span></span><br><span class="line">                parkAndCheckInterrupt()) <span class="comment">// 挂起线程进入等待状态，等待被唤醒，如果在等待状态下被中断，那么会返回 true，直接将中断标志设为 true，否则就是正常唤醒，继续自旋</span></span><br><span class="line">                interrupted = <span class="literal">true</span>; <span class="comment">// 标记当前线程被中断</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) <span class="comment">// 如果获取锁失败</span></span><br><span class="line">            cancelAcquire(node); <span class="comment">// 取消当前节点的获取请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>); <span class="comment">// 通过 unsafe 类操作底层挂起线程（会直接进入阻塞状态）</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted(); <span class="comment">// 检查并清除中断状态，返回当前线程是否被中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus; <span class="comment">// 获取前驱节点的等待状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 已经是 SIGNAL，直接返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123; <span class="comment">// 不能是已经取消的节点，必须找到一个没被取消的</span></span><br><span class="line">        <span class="keyword">do</span> &#123;  </span><br><span class="line">            node.prev = pred = pred.prev; <span class="comment">// 将节点的前驱指针更新为前驱节点的前驱</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>); <span class="comment">// 继续向前查找，直到遇到一个没有被取消的节点</span></span><br><span class="line">        pred.next = node; <span class="comment">// 直接抛弃被取消的节点，连接当前节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">// 不是 SIGNAL，先 CAS 设置为 SIGNAL（这里没有返回 true 因为 CAS 不一定成功，需要下一轮再判断一次）</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL); <span class="comment">// 尝试通过 CAS 设置前驱节点的等待状态为 SIGNAL</span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 返回 false，马上开启下一轮循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，<code>acquire()</code>中的<code>if</code>条件如果为<code>true</code>，那么只有一种情况，就是等待过程中被中断了</p>
<p>其他任何情况下都是成功获取到独占锁，所以当等待过程被中断时，会调用<code>selfInterrupt()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selfInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread.currentThread().interrupt(); <span class="comment">// 直接向当前线程发送中断信号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>公平锁的<code>tryAcquire()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="meta">@ReservedStackAccess</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread(); <span class="comment">// 先获取当前线程的 Thread 对象</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState(); <span class="comment">// 获取当前 AQS 对象状态（独占模式下 0 为未占用，大于 0 表示已占用）</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 如果是 0，那就表示没有占用，现在线程就要来尝试占用它</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">// 等待队列是否不为空且当前线程没有拿到锁，其实就是看看当前线程有没有必要进行排队，如果没必要排队，就说明可以直接获取锁</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">// CAS 设置状态，如果成功则说明成功拿到了这把锁，失败则说明可能这个时候其他线程在争抢，并且还先抢到</span></span><br><span class="line">                setExclusiveOwnerThread(current); <span class="comment">// 成功拿到锁，会将独占模式所有者线程设定为当前线程（这个方法是父类 AbstractOwnableSynchronizer 中的，就表示当前这把锁已经是这个线程的了）</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 占用锁成功，返回 true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// 如果不是 0，那就表示被线程占用了，这个时候看看是不是自己占用的，如果是，由于是可重入锁，可以继续加锁</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires; <span class="comment">// 多次加锁会将状态值进行增加，状态值就是加锁次数</span></span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// 加到 int 值溢出了？</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc); <span class="comment">// 设置为新的加锁次数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 成功加锁，返回 true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 其他任何情况都是加锁失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="公平锁解锁"><a href="#公平锁解锁" class="headerlink" title="公平锁解锁"></a>公平锁解锁</h4><p><code>AQS</code>的解锁过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>); <span class="comment">// 直接调用了 AQS 中的 release 方法，参数为 1 表示解锁一次，state--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">// 和 tryAcquire 一样，也得子类去重写，释放锁操作</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// 释放锁成功后，获取新的头结点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) &#123; <span class="comment">// 如果新的头结点不为空并且不是刚刚建立的结点（初始状态下 status 为默认值 0，而上面在进行了 shouldParkAfterFailedAcquire 之后，会被设定为 SIGNAL 状态，值为 -1）</span></span><br><span class="line">            unparkSuccessor(h); <span class="comment">// 唤醒头节点下一个节点中的线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 释放锁成功</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 释放锁失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123; <span class="comment">// 定义 unparkSuccessor 方法，用于唤醒下一个节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus; <span class="comment">// 获取当前节点的等待状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) <span class="comment">// 如果等待状态小于 0，即节点处于被中断或取消的状态</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>); <span class="comment">// 将当前节点的等待状态设置为初始值 0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next; <span class="comment">// 获取下一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果下一个节点为空或等待状态大于 0，表示该节点已被取消，不能通知 unpark</span></span><br><span class="line">        s = <span class="literal">null</span>; <span class="comment">// 将下一个节点设为 null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev) <span class="comment">// 从队尾向前遍历节点，直到找到一个等待状态小于等于 0 的节点</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) <span class="comment">// 如果找到了符合条件的节点</span></span><br><span class="line">                s = t; <span class="comment">// 更新 s 为找到的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>) <span class="comment">// 如果找到了合适的节点</span></span><br><span class="line">        LockSupport.unpark(s.thread); <span class="comment">// 唤醒该节点所对应的线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Sync</code>的<code>tryRelease()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123; <span class="comment">// 尝试释放锁，返回是否释放成功</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases; <span class="comment">// 先计算本次解锁之后的状态值</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) <span class="comment">// 因为是独占锁，那肯定这把锁得是当前线程持有才行</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>(); <span class="comment">// 否则直接抛异常</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 用于标记是否成功释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 如果解锁之后的值为 0，表示已经完全释放此锁</span></span><br><span class="line">        free = <span class="literal">true</span>; <span class="comment">// 设置释放标志为 true</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>); <span class="comment">// 将独占锁持有线程设置为 null</span></span><br><span class="line">    &#125;</span><br><span class="line">    setState(c); <span class="comment">// 状态值设定为 c</span></span><br><span class="line">    <span class="keyword">return</span> free; <span class="comment">// 如果不是 0 表示此锁还没完全释放，返回 false，是 0 就返回 true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/13%20JavaJUC%20%E5%A4%9A%E7%BA%BF%E7%A8%8B-11.jpg"></p>
<h3 id="公平锁一定公平吗？"><a href="#公平锁一定公平吗？" class="headerlink" title="公平锁一定公平吗？"></a>公平锁一定公平吗？</h3><p>来回顾一下<code>tryAcquire()</code>方法的实现：         </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">// 注意这里，公平锁的机制是，一开始会查看是否有节点处于等待</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">// 如果前面的方法执行后发现没有等待节点，就直接进入占锁环节了</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如现在出现了这样的情况：</p>
<p>线程 1 已经持有锁了，这时线程 2 来争抢这把锁，走到<code>hasQueuedPredecessors()</code>，判断出为 <code>false</code></p>
<p>线程 2 继续运行，然后线程 2 肯定获取锁失败（因为锁这时是被线程 1 占有的），因此就进入到等待队列中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123; <span class="comment">// 由于一开始 head 和 tail 都是 null，所以线程 2 直接就进 enq() 了</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// 线程 2 进来之后，肯定是要先走这里的，因为 head 和 tail 都是 null</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head; <span class="comment">// 这里就将 tail 直接等于 head 了，注意这里完了之后还没完，这里只是初始化过程</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而碰巧不巧，这个时候线程 3 也来抢锁了</p>
<p>按照正常流程走到了<code>hasQueuedPredecessors()</code>方法，而在此方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    Node s;</span><br><span class="line">  	<span class="comment">// 这里直接判断 h != t，而此时线程 2 才刚刚执行完 tail = head，所以直接就返回 false 了</span></span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="literal">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，线程 3 这时就紧接着准备开始 CAS 操作了。又碰巧，这时线程 1 释放锁了</p>
<p>现在的情况就是，线程 3 直接开始 CAS 判断，而线程 2 还在插入节点状态</p>
<p>结果可想而知，居然是线程 3 先拿到了锁，这显然是违背了公平锁的公平机制</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/13%20JavaJUC%20%E5%A4%9A%E7%BA%BF%E7%A8%8B-12.jpg"></p>
<p>因此公不公平全看<code>hasQueuedPredecessors()</code>，而此方法只有在等待队列中存在节点时才能保证不会出现问题</p>
<p>所以公平锁，只有在等待队列存在节点时，才是真正公平的</p>
<h3 id="Condition-实现原理"><a href="#Condition-实现原理" class="headerlink" title="Condition 实现原理"></a>Condition 实现原理</h3><p>在<code>AQS</code>中，<code>Condition</code>有一个实现类<code>ConditionObject</code>，而这里也是使用了链表实现了条件队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConditionObject</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1173984872572414699L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter; <span class="comment">// 条件队列的头结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter; <span class="comment">// 条件队列的尾结点</span></span><br><span class="line">  </span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是直接使用了<code>AQS</code>中的<code>Node</code>类，但是使用的是<code>Node</code>类中的<code>nextWaiter</code>字段连接节点，并且<code>Node</code>的<code>status</code>为<code>CONDITION</code>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/13%20JavaJUC%20%E5%A4%9A%E7%BA%BF%E7%A8%8B-13.jpg"></p>
<p>当一个线程调用<code>await()</code>方法时，会进入等待状态，直到其他线程调用<code>signal()</code>方法将其唤醒</p>
<p>而这里的条件队列，正是用于存储这些处于<strong>等待状态</strong>的线程</p>
<p><code>await()</code>方法的目标：</p>
<ul>
<li>只有已经持有锁的线程才可以使用此方法</li>
<li>当调用此方法后，会直接释放锁，无论加了多少次锁</li>
<li>只有其他线程调用<code>signal()</code>或是被中断时才会唤醒等待中的线程</li>
<li>被唤醒后，需要等待其他线程释放锁，拿到锁之后才可以继续执行，并且会恢复到之前的状态</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>(); <span class="comment">// 如果在调用 await 之前就被添加了中断标记，那么会直接抛出中断异常</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter(); <span class="comment">// 为当前线程创建一个新的节点，并将其加入到条件队列中</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node); <span class="comment">// 完全释放当前线程持有的锁，并且保存一下 state 值，因为唤醒之后还得恢复</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 用于保存中断状态</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123; <span class="comment">// 循环判断是否位于同步队列中，如果等待状态下的线程被其他线程唤醒，那么会正常进入到 AQS 的等待队列中</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>); <span class="comment">// 如果依然处于等待状态，那么继续挂起</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>) <span class="comment">// 看看等待的时候是不是被中断了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出了循环之后，那线程肯定是已经醒了，这时就差拿到锁就可以恢复运行了</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) <span class="comment">// 直接开始 acquireQueued 尝试拿锁（之前已经讲过了）从这里开始基本就和一个线程去抢锁是一样的了</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="comment">// 已经拿到锁了，基本可以开始继续运行了，这里再进行一下后期清理工作</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) </span><br><span class="line">        unlinkCancelledWaiters(); <span class="comment">// 将等待队列中，不是 Node.CONDITION 状态的节点移除</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>) <span class="comment">// 依然是响应中断</span></span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>signal()</code>方法的目标：</p>
<ul>
<li>只有持有锁的线程才能唤醒锁所属的<code>Condition</code>等待的线程</li>
<li>优先唤醒条件队列中的第一个，如果唤醒过程中出现问题，接着找往下找，直到找到一个可以唤醒的</li>
<li>唤醒操作本质上是将条件队列中的结点直接丢进<code>AQS</code>等待队列中，让其参与到锁的竞争中</li>
<li>拿到锁之后，线程才能恢复运行</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/13%20JavaJUC%20%E5%A4%9A%E7%BA%BF%E7%A8%8B-14.jpg">           </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively()) <span class="comment">// 先看看当前线程是不是持有锁的状态</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter; <span class="comment">// 获取条件队列的第一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>) <span class="comment">// 如果队列不为空，获取到了，那么就可以开始唤醒操作</span></span><br><span class="line">        doSignal(first); <span class="comment">// 执行唤醒操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123; <span class="comment">// 定义 doSignal 方法，处理条件队列中的信号</span></span><br><span class="line">    <span class="keyword">do</span> &#123; <span class="comment">// 开始循环，处理队列中的节点</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>) <span class="comment">// 如果当前节点在本轮循环没有后继节点了，条件队列就为空了</span></span><br><span class="line">            lastWaiter = <span class="literal">null</span>; <span class="comment">// 所以这里相当于是直接清空</span></span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>; <span class="comment">// 将给定节点的下一个结点设置为 null，因为当前结点马上就会离开条件队列了</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="literal">null</span>); <span class="comment">// 能走到这里只能说明给定节点被设定为了取消状态，那就继续看下一个结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123; <span class="comment">// 定义 transferForSignal 方法，用于处理节点的信号传递</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) <span class="comment">// 如果 CAS 操作失败，表示节点的等待状态已经被取消，返回 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CAS 成功之后，节点的等待状态变成默认值 0，接着通过 enq 方法将节点丢进 AQS 的等待队列，相当于唤醒并等待获取锁</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node); <span class="comment">// 将节点加入到 AQS 的等待队列，返回队尾的前驱节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus; <span class="comment">// 保存前驱节点的等待状态</span></span><br><span class="line">    <span class="comment">// 如果上一个节点的状态为取消，或者尝试设置上一个节点的状态为 SIGNAL 失败（可能是在 ws &gt; 0 判断完之后马上变成取消状态，导致 CAS 失败）</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) <span class="comment">// 如果前驱节点的等待状态为取消，或者 CAS 操作失败</span></span><br><span class="line">        LockSupport.unpark(node.thread); <span class="comment">// 直接唤醒当前节点对应的线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 返回 true，表示节点成功传递了信号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/13%20JavaJUC%20%E5%A4%9A%E7%BA%BF%E7%A8%8B-15.jpg"></p>
<h2 id="自行实现锁类"><a href="#自行实现锁类" class="headerlink" title="自行实现锁类"></a>自行实现锁类</h2><p>要求：同一时间只能有一个线程持有锁，不要求可重入（反复加锁无视即可）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123; <span class="comment">// 自行实现一个最普通的独占锁</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设计思路：</span></span><br><span class="line"><span class="comment">         * 1. 锁被占用，那么 exclusiveOwnerThread 应该被记录，并且 state = 1</span></span><br><span class="line"><span class="comment">         * 2. 锁没有被占用，那么 exclusiveOwnerThread 为 null，并且 state = 0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(isHeldExclusively()) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 无需可重入功能，如果是当前线程直接返回 true</span></span><br><span class="line">                <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>, arg)) &#123; <span class="comment">// CAS 操作进行状态替换</span></span><br><span class="line">                    setExclusiveOwnerThread(Thread.currentThread()); <span class="comment">// 成功后设置当前的所有者线程</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(getState() == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>(); <span class="comment">// 没加锁情况下是不能直接解锁的</span></span><br><span class="line">                <span class="keyword">if</span>(isHeldExclusively()) &#123; <span class="comment">// 只有持有锁的线程才能解锁</span></span><br><span class="line">                    setExclusiveOwnerThread(<span class="literal">null</span>); <span class="comment">// 设置所有者线程为 null</span></span><br><span class="line">                    setState(<span class="number">0</span>); <span class="comment">// 状态变为 0</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">protected</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            sync.acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">            sync.release(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h1><h3 id="基本数据类"><a href="#基本数据类" class="headerlink" title="基本数据类"></a>基本数据类</h3><h4 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h4><p>原子更新<code>int</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(值)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">i.get() <span class="comment">// 获取当前值</span></span><br><span class="line">i.set(<span class="type">int</span> newValue) <span class="comment">// 设置为指定的新值</span></span><br><span class="line"></span><br><span class="line">i.getAndSet(<span class="type">int</span> newValue) <span class="comment">// 获取当前值并将其更新为新值，返回旧值</span></span><br><span class="line">i.compareAndSet(<span class="type">int</span> expect, <span class="type">int</span> update) <span class="comment">// 如果当前值等于预期值，则将其更新为新值</span></span><br><span class="line">i.getAndIncrement() <span class="comment">// 获取当前值并递增</span></span><br><span class="line">i.incrementAndGet() <span class="comment">// 将当前值递增并返回更新后的新值</span></span><br><span class="line">i.getAndDecrement() <span class="comment">// 获取当前值并递减</span></span><br><span class="line">i.decrementAndGet() <span class="comment">// 将当前值递减并返回更新后的新值</span></span><br><span class="line">i.addAndGet(<span class="type">int</span> delta) <span class="comment">// 将当前值增加指定的值并返回新值</span></span><br><span class="line">i.getAndAdd(<span class="type">int</span> delta) <span class="comment">// 获取当前值并将指定的值加到当前值，返回旧值</span></span><br><span class="line"></span><br><span class="line">i.toString() <span class="comment">// 获取当前值的字符串表示</span></span><br><span class="line">i.intValue() <span class="comment">// 返回当前值的普通 int 类型</span></span><br><span class="line">i.longValue() <span class="comment">// 返回当前值的 long 类型</span></span><br><span class="line">i.floatValue() <span class="comment">// 返回当前值的 float 类型</span></span><br><span class="line">i.doubleValue() <span class="comment">// 返回当前值的 double 类型</span></span><br><span class="line">i.weakCompareAndSet(<span class="type">int</span> expect, <span class="type">int</span> update) <span class="comment">// 与 compareAndSet 类似，但使用弱一致性</span></span><br></pre></td></tr></table></figure>

<h4 id="AtomicLong"><a href="#AtomicLong" class="headerlink" title="AtomicLong"></a>AtomicLong</h4><p>原子更新<code>long</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicLong</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(值)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">i.get() <span class="comment">// 获取当前值</span></span><br><span class="line">i.set(<span class="type">long</span> newValue) <span class="comment">// 设置为指定的新值</span></span><br><span class="line"></span><br><span class="line">i.getAndSet(<span class="type">long</span> newValue) <span class="comment">// 获取当前值并将其更新为新值，返回旧值</span></span><br><span class="line">i.compareAndSet(<span class="type">long</span> expect, <span class="type">long</span> update) <span class="comment">// 如果当前值等于预期值，则将其更新为新值</span></span><br><span class="line">i.getAndIncrement() <span class="comment">// 获取当前值并递增</span></span><br><span class="line">i.incrementAndGet() <span class="comment">// 将当前值递增并返回更新后的新值</span></span><br><span class="line">i.getAndDecrement() <span class="comment">// 获取当前值并递减</span></span><br><span class="line">i.decrementAndGet() <span class="comment">// 将当前值递减并返回更新后的新值</span></span><br><span class="line">i.addAndGet(<span class="type">long</span> delta) <span class="comment">// 将当前值增加指定的值并返回新值</span></span><br><span class="line">i.getAndAdd(<span class="type">long</span> delta) <span class="comment">// 获取当前值并将指定的值加到当前值，返回旧值</span></span><br><span class="line"></span><br><span class="line">i.toString() <span class="comment">// 获取当前值的字符串表示</span></span><br><span class="line">i.intValue() <span class="comment">// 返回当前值的普通 int 类型</span></span><br><span class="line">i.longValue() <span class="comment">// 返回当前值的 long 类型</span></span><br><span class="line">i.floatValue() <span class="comment">// 返回当前值的 float 类型</span></span><br><span class="line">i.doubleValue() <span class="comment">// 返回当前值的 double 类型</span></span><br><span class="line">i.weakCompareAndSet(<span class="type">long</span> expect, <span class="type">long</span> update) <span class="comment">// 与 compareAndSet 类似，但使用弱一致性</span></span><br></pre></td></tr></table></figure>

<h4 id="AtomicBoolean"><a href="#AtomicBoolean" class="headerlink" title="AtomicBoolean"></a>AtomicBoolean</h4><p>原子更新<code>boolean</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicBoolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b.get() <span class="comment">// 获取当前值</span></span><br><span class="line">b.set(<span class="type">boolean</span> newValue) <span class="comment">// 设置为指定的新值</span></span><br><span class="line"></span><br><span class="line">b.getAndSet(<span class="type">boolean</span> newValue) <span class="comment">// 获取当前值并将其更新为新值，返回旧值</span></span><br><span class="line">b.compareAndSet(<span class="type">boolean</span> expect, <span class="type">boolean</span> update) <span class="comment">// 如果当前值等于预期值，则将其更新为新值</span></span><br><span class="line">b.toString() <span class="comment">// 获取当前值的字符串表示</span></span><br></pre></td></tr></table></figure>

<h3 id="数组类"><a href="#数组类" class="headerlink" title="数组类"></a>数组类</h3><h4 id="AtomicIntegerArray"><a href="#AtomicIntegerArray" class="headerlink" title="AtomicIntegerArray"></a>AtomicIntegerArray</h4><p>原子更新<code>int</code>数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicIntegerArray</span> <span class="variable">arr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(数组)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">arr.get(<span class="type">int</span> index) <span class="comment">// 获取指定索引的当前值</span></span><br><span class="line">arr.set(<span class="type">int</span> index, <span class="type">int</span> newValue) <span class="comment">// 设置指定索引的值为新值</span></span><br><span class="line">    </span><br><span class="line">arr.getAndSet(<span class="type">int</span> index, <span class="type">int</span> newValue) <span class="comment">// 获取指定索引的当前值并将其更新为新值，返回旧值</span></span><br><span class="line">arr.compareAndSet(<span class="type">int</span> index, <span class="type">int</span> expect, <span class="type">int</span> update) <span class="comment">// 如果指定索引的当前值等于预期值，则将其更新为新值</span></span><br><span class="line">arr.getAndIncrement(<span class="type">int</span> index) <span class="comment">// 获取指定索引的当前值并递增，返回旧值</span></span><br><span class="line">arr.incrementAndGet(<span class="type">int</span> index) <span class="comment">// 将指定索引的值递增并返回更新后的新值</span></span><br><span class="line">arr.getAndDecrement(<span class="type">int</span> index) <span class="comment">// 获取指定索引的当前值并递减，返回旧值</span></span><br><span class="line">arr.decrementAndGet(<span class="type">int</span> index) <span class="comment">// 将指定索引的值递减并返回更新后的新值</span></span><br><span class="line">arr.addAndGet(<span class="type">int</span> index, <span class="type">int</span> delta) <span class="comment">// 将指定索引的值增加指定的增量并返回新值</span></span><br><span class="line">arr.getAndAdd(<span class="type">int</span> index, <span class="type">int</span> delta) <span class="comment">// 获取指定索引的当前值并将指定的增量加到当前值，返回旧值</span></span><br><span class="line">    </span><br><span class="line">arr.length() <span class="comment">// 返回数组的长度</span></span><br><span class="line">arr.toString() <span class="comment">// 获取当前值的字符串表示</span></span><br><span class="line">arr.atomic(<span class="type">int</span> index) <span class="comment">// 获取指定索引的原子值（可以用来处理更多自定义操作）</span></span><br></pre></td></tr></table></figure>

<h4 id="AtomicLongArray"><a href="#AtomicLongArray" class="headerlink" title="AtomicLongArray"></a>AtomicLongArray</h4><p>原子更新<code>long</code>数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicLongArray</span> <span class="variable">arr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLongArray</span>(数组)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">arr.get(<span class="type">int</span> index) <span class="comment">// 获取指定索引的当前值</span></span><br><span class="line">arr.set(<span class="type">int</span> index, <span class="type">long</span> newValue) <span class="comment">// 设置指定索引的值为新值</span></span><br><span class="line"></span><br><span class="line">arr.getAndSet(<span class="type">int</span> index, <span class="type">long</span> newValue) <span class="comment">// 获取指定索引的当前值并将其更新为新值，返回旧值</span></span><br><span class="line">arr.compareAndSet(<span class="type">int</span> index, <span class="type">long</span> expect, <span class="type">long</span> update) <span class="comment">// 如果指定索引的当前值等于预期值，则将其更新为新值</span></span><br><span class="line">arr.getAndIncrement(<span class="type">int</span> index) <span class="comment">// 获取指定索引的当前值并递增，返回旧值</span></span><br><span class="line">arr.incrementAndGet(<span class="type">int</span> index) <span class="comment">// 将指定索引的值递增并返回更新后的新值</span></span><br><span class="line">arr.getAndDecrement(<span class="type">int</span> index) <span class="comment">// 获取指定索引的当前值并递减，返回旧值</span></span><br><span class="line">arr.decrementAndGet(<span class="type">int</span> index) <span class="comment">// 将指定索引的值递减并返回更新后的新值</span></span><br><span class="line">arr.addAndGet(<span class="type">int</span> index, <span class="type">long</span> delta) <span class="comment">// 将指定索引的值增加指定的增量并返回新值</span></span><br><span class="line">arr.getAndAdd(<span class="type">int</span> index, <span class="type">long</span> delta) <span class="comment">// 获取指定索引的当前值并将指定的增量加到当前值，返回旧值</span></span><br><span class="line"></span><br><span class="line">arr.length() <span class="comment">// 返回数组的长度</span></span><br><span class="line">arr.toString() <span class="comment">// 获取当前数组值的字符串表示</span></span><br><span class="line">arr.atomic(<span class="type">int</span> index) <span class="comment">// 获取指定索引的原子值（用于处理更复杂的操作）</span></span><br><span class="line">arr.longValue() <span class="comment">// 返回指定索引的值的 long 类型</span></span><br><span class="line">arr.intValue() <span class="comment">// 返回指定索引的值的 int 类型</span></span><br><span class="line">arr.floatValue() <span class="comment">// 返回指定索引的值的 float 类型</span></span><br><span class="line">arr.doubleValue() <span class="comment">// 返回指定索引的值的 double 类型</span></span><br></pre></td></tr></table></figure>

<h4 id="AtomicReferenceArray"><a href="#AtomicReferenceArray" class="headerlink" title="AtomicReferenceArray"></a>AtomicReferenceArray</h4><p>原子更新引用数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicReferenceArray</span> <span class="variable">arr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicReferenceArray</span>(数组)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">arr.get(<span class="type">int</span> index) <span class="comment">// 获取指定索引的当前值</span></span><br><span class="line">arr.set(<span class="type">int</span> index, V newValue) <span class="comment">// 设置指定索引的值为新值</span></span><br><span class="line"></span><br><span class="line">arr.getAndSet(<span class="type">int</span> index, V newValue) <span class="comment">// 获取指定索引的当前值并将其更新为新值，返回旧值</span></span><br><span class="line">arr.compareAndSet(<span class="type">int</span> index, V expect, V update) <span class="comment">// 如果指定索引的当前值等于预期值，则将其更新为新值</span></span><br><span class="line">arr.lazySet(<span class="type">int</span> index, V newValue) <span class="comment">// 延迟设置指定索引的值，可能不会立即生效</span></span><br><span class="line">arr.length() <span class="comment">// 返回数组的长度</span></span><br><span class="line">arr.toString() <span class="comment">// 获取当前数组值的字符串表示</span></span><br><span class="line">arr.getReference(<span class="type">int</span> index) <span class="comment">// 获取指定索引的引用值（在某些实现中可能为其他操作）</span></span><br><span class="line">arr.getAndUpdate(<span class="type">int</span> index, UnaryOperator&lt;V&gt; updateFunction) <span class="comment">// 使用给定的更新函数更新并返回旧值</span></span><br><span class="line">arr.updateAndGet(<span class="type">int</span> index, UnaryOperator&lt;V&gt; updateFunction) <span class="comment">// 使用给定的更新函数更新并返回新值</span></span><br><span class="line">arr.getAndAccumulate(<span class="type">int</span> index, V delta, BinaryOperator&lt;V&gt; accumulator) <span class="comment">// 使用给定的累加器函数更新值，并返回旧值</span></span><br><span class="line">arr.accumulateAndGet(<span class="type">int</span> index, V delta, BinaryOperator&lt;V&gt; accumulator) <span class="comment">// 使用给定的累加器函数更新值，并返回新值</span></span><br><span class="line">    </span><br><span class="line">arr.intValue(<span class="type">int</span> index) <span class="comment">// 返回指定索引的值的 int 类型</span></span><br><span class="line">arr.longValue(<span class="type">int</span> index) <span class="comment">// 返回指定索引的值的 long 类型</span></span><br><span class="line">arr.floatValue(<span class="type">int</span> index) <span class="comment">// 返回指定索引的值的 float 类型</span></span><br><span class="line">arr.doubleValue(<span class="type">int</span> index) <span class="comment">// 返回指定索引的值的 double 类型</span></span><br></pre></td></tr></table></figure>

<h3 id="ABA-问题及解决方案"><a href="#ABA-问题及解决方案" class="headerlink" title="ABA 问题及解决方案"></a>ABA 问题及解决方案</h3><p><strong>问题引入</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/13%20JavaJUC%20%E5%A4%9A%E7%BA%BF%E7%A8%8B-16.jpg"></p>
<p>线程 1 和线程 2 同时开始对<code>a</code>的值进行 CAS 修改</p>
<p>但是线程 1 的速度比较快，将<code>a</code>的值修改为<code>2</code>之后紧接着又修改回<code>1</code></p>
<p>这时线程2才开始进行判断，发现<code>a</code>的值是<code>1</code>，所以 CAS 操作成功</p>
<p>很明显，这里的<code>1</code>已经不是一开始的那个<code>1</code>了，而是被重新赋值的<code>1</code>，这也是 CAS 操作存在的问题</p>
<p>它只会机械地比较当前值是不是预期值，但是并不会关心当前值是否被修改过，这种问题称之为 <strong>ABA 问题</strong></p>
<p><strong>解决方案</strong>：</p>
<p>JUC 提供了带版本号的引用类型，只要每次操作都记录一下版本号，并且版本号不会重复，那么就可以解决 ABA 问题了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    AtomicStampedReference&lt;String&gt; reference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(a, <span class="number">1</span>); <span class="comment">// 在构造时需要指定初始值和对应的版本号</span></span><br><span class="line">    reference.attemptStamp(a, <span class="number">2</span>); <span class="comment">// 可以中途对版本号进行修改，注意要填写当前的引用对象</span></span><br><span class="line">    System.out.println(reference.compareAndSet(a, b, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// CAS 操作时不仅需要提供预期值和修改值，还要提供预期版本号和新的版本号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;()</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法同 ArrayList</span></span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;T, V&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法同 HashMap</span></span><br></pre></td></tr></table></figure>

<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><ol>
<li><p><strong>固定大小</strong>：大小在创建时就必须指定，并且大小是固定的，它不会自动扩容</p>
</li>
<li><p><strong>阻塞操作</strong>：它支持阻塞式的插入和移除操作：</p>
<ul>
<li>当队列已满时，生产者线程会被阻塞，直到队列有空余位置</li>
<li>当队列为空时，消费者线程会被阻塞，直到队列中有元素可供消费</li>
</ul>
</li>
<li><p><strong>线程安全</strong>：内部通过使用锁确保多线程的安全性。在多个线程之间对队列进行插入、删除等操作时，它能避免数据不一致的问题</p>
</li>
<li><p><strong>公平性</strong>：可以选择公平性策略</p>
<p>​			    如果使用公平锁，会按照线程请求的顺序处理队列操作，防止线程饥饿</p>
<p>​				否则，线程的执行顺序是无序的</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;T&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="type">int</span> capacity) <span class="comment">// 创建一个指定容量的队列，默认不使用公平性</span></span><br><span class="line">Queue&lt;T&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="type">int</span> capacity, <span class="type">boolean</span> fair) <span class="comment">// 创建一个指定容量的队列，并指定是否使用公平性</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">q.add(E e) <span class="comment">// 插入元素 e，如果队列已满则抛出 IllegalStateException</span></span><br><span class="line">q.offer(E e) <span class="comment">// 插入元素 e，如果队列已满返回 false（非阻塞）</span></span><br><span class="line">q.offer(E e, <span class="type">long</span> timeout, TimeUnit unit) <span class="comment">// 尝试在指定时间内插入元素 e，如果队列已满则阻塞指定时间</span></span><br><span class="line">q.put(E e) <span class="comment">// 插入元素 e，如果队列已满则阻塞，直到有空间</span></span><br><span class="line">q.take() <span class="comment">// 移除并返回队头元素，如果队列为空则阻塞</span></span><br><span class="line">q.poll(<span class="type">long</span> timeout, TimeUnit unit) <span class="comment">// 尝试移除并返回队头元素，如果队列为空则阻塞指定时间</span></span><br><span class="line">q.poll() <span class="comment">// 移除并返回队头元素，如果队列为空则返回 null（非阻塞）</span></span><br><span class="line">q.peek() <span class="comment">// 返回队头元素，但不移除，如果队列为空返回 null</span></span><br><span class="line">q.remove() <span class="comment">// 移除队头元素，如果队列为空则抛出异常</span></span><br><span class="line">q.size() <span class="comment">// 返回队列当前元素的个数</span></span><br><span class="line">q.isEmpty() <span class="comment">// 判断队列是否为空</span></span><br><span class="line">q.isFull() <span class="comment">// 判断队列是否已满</span></span><br><span class="line">q.clear() <span class="comment">// 清空队列中的所有元素</span></span><br></pre></td></tr></table></figure>

<h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><ol>
<li><p><strong>零容量队列</strong>：它不存储任何元素。每个插入操作必须等待另一个线程的移除操作，反之亦然</p>
</li>
<li><p><strong>线程同步</strong>：它用于在两个线程之间进行数据交换</p>
<p>​				    当一个线程插入元素时，它必须等待另一个线程将其取走</p>
<p>​					同样，当一个线程试图取出元素时，它必须等待另一个线程插入元素</p>
</li>
<li><p><strong>不支持缓存</strong>：没有缓存功能，它不会缓存任何元素，因此每次插入和移除操作都必须在两个线程之间进行同步</p>
</li>
<li><p><strong>无容量</strong>：队列的容量为零，因此它是实现线程间交换的理想工具，常用于实现线程池任务的处理</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;T&gt; q = <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>() <span class="comment">// 创建一个新的空的 SynchronousQueue，默认是非公平的</span></span><br><span class="line">Queue&lt;T&gt; q = <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>(<span class="type">boolean</span> fair) <span class="comment">// 创建一个新的空的 SynchronousQueue，可以指定是否使用公平性策略</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">q.put(E e) <span class="comment">// 插入元素 e，如果队列为空则阻塞，直到另一个线程调用 take() 获取元素</span></span><br><span class="line">q.take() <span class="comment">// 移除并返回队头元素，如果队列为空则阻塞，直到另一个线程调用 put() 插入元素</span></span><br><span class="line">q.poll(<span class="type">long</span> timeout, TimeUnit unit) <span class="comment">// 尝试在指定时间内移除并返回队头元素，如果队列为空则阻塞指定时间</span></span><br><span class="line">q.poll() <span class="comment">// 尝试移除并返回队头元素，如果队列为空则返回 null（非阻塞）</span></span><br><span class="line">q.isEmpty() <span class="comment">// 判断队列是否为空</span></span><br><span class="line">q.size() <span class="comment">// 返回队列当前元素的数量，始终为 0 或 1</span></span><br><span class="line">q.clear() <span class="comment">// 清空队列中的所有元素（此方法通常不适用，因为队列中没有持久存储的元素）</span></span><br></pre></td></tr></table></figure>

<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><ol>
<li><p><strong>有容量的阻塞队列</strong>：一个基于链表实现的阻塞队列，它可以选择指定容量，也可以使用默认的无界容量</p>
<p>​								   通过容量控制线程之间的同步</p>
</li>
<li><p><strong>线程安全</strong>：可以在多个线程间安全地进行插入和移除操作</p>
</li>
<li><p><strong>支持阻塞操作</strong>：如果队列满了，插入操作会阻塞；如果队列空了，移除操作会阻塞</p>
</li>
<li><p><strong>适用于生产者-消费者模型</strong>：由于其线程安全和阻塞特性，它广泛用于生产者-消费者问题的解决方案，适合任务调度和线程池的实现</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;T&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>() <span class="comment">// 创建一个默认容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue</span></span><br><span class="line">Queue&lt;T&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>(<span class="type">int</span> capacity) <span class="comment">// 创建一个指定容量的 LinkedBlockingQueue</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">q.put(E e) <span class="comment">// 插入元素 e，如果队列已满则阻塞，直到有空间可用</span></span><br><span class="line">q.take() <span class="comment">// 移除并返回队头元素，如果队列为空则阻塞，直到有元素可用</span></span><br><span class="line">q.offer(E e) <span class="comment">// 尝试插入元素 e，如果队列未满则返回 true，否则返回 false（非阻塞）</span></span><br><span class="line">q.offer(E e, <span class="type">long</span> timeout, TimeUnit unit) <span class="comment">// 尝试在指定时间内插入元素 e，如果队列未满则返回 true，否则返回 false（带超时）</span></span><br><span class="line">q.poll(<span class="type">long</span> timeout, TimeUnit unit) <span class="comment">// 尝试在指定时间内移除并返回队头元素，如果队列为空则阻塞指定时间</span></span><br><span class="line">q.poll() <span class="comment">// 尝试移除并返回队头元素，如果队列为空则返回 null（非阻塞）</span></span><br><span class="line">q.peek() <span class="comment">// 返回队头元素但不移除它，如果队列为空则返回 null</span></span><br><span class="line">q.isEmpty() <span class="comment">// 判断队列是否为空</span></span><br><span class="line">q.size() <span class="comment">// 返回队列当前元素的数量</span></span><br><span class="line">q.clear() <span class="comment">// 清空队列中的所有元素</span></span><br><span class="line">q.drainTo(Collection&lt;? <span class="built_in">super</span> E&gt; c) <span class="comment">// 移除队列中的所有元素并将其添加到给定的集合 c 中</span></span><br></pre></td></tr></table></figure>

<h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><ol>
<li><p><strong>优先级队列</strong>：一个支持优先级排序的阻塞队列，队列中的元素根据其优先级进行排序，优先级高的元素会先被移除</p>
<p>​					   默认使用元素的自然顺序，或者可以通过提供自定义的比较器来控制排序</p>
</li>
<li><p><strong>线程安全</strong>：可以在多个线程中安全地进行插入和移除操作</p>
</li>
<li><p><strong>无界队列</strong>：它是一个无界队列，即队列的容量仅受系统可用内存的限制，不会因为达到容量限制而阻塞插入操作</p>
<p>​				    插入操作会继续，直到内存不足</p>
</li>
<li><p><strong>阻塞操作</strong>：尽管它是无界的，它仍然可以进行阻塞操作。当调用 <code>take()</code> 时，如果队列为空，它会阻塞直到有元素可用</p>
</li>
<li><p><strong>适用场景</strong>：常用于处理具有优先级的任务调度、事件处理等场景</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;T&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityBlockingQueue</span>() <span class="comment">// 创建一个无界的 PriorityBlockingQueue，默认按照元素的自然顺序进行排序</span></span><br><span class="line">Queue&lt;T&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityBlockingQueue</span>(<span class="type">int</span> initialCapacity) <span class="comment">// 创建一个具有指定初始容量的无界 PriorityBlockingQueue</span></span><br><span class="line">Queue&lt;T&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityBlockingQueue</span>(<span class="type">int</span> initialCapacity, <span class="type">int</span> capacity, Comparator&lt;? <span class="built_in">super</span> E&gt; comparator) <span class="comment">// 创建一个具有指定初始容量和自定义排序规则的无界 PriorityBlockingQueue</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">q.put(E e) <span class="comment">// 插入元素 e，如果队列已满则阻塞，直到有空间可用（无界队列一般不会阻塞插入）</span></span><br><span class="line">q.take() <span class="comment">// 移除并返回队头元素（优先级最高的元素），如果队列为空则阻塞，直到有元素可用</span></span><br><span class="line">q.offer(E e) <span class="comment">// 尝试插入元素 e，如果队列未满则返回 true，否则返回 false（非阻塞）</span></span><br><span class="line">q.offer(E e, <span class="type">long</span> timeout, TimeUnit unit) <span class="comment">// 尝试在指定时间内插入元素 e，如果队列未满则返回 true，否则返回 false（带超时）</span></span><br><span class="line">q.poll(<span class="type">long</span> timeout, TimeUnit unit) <span class="comment">// 尝试在指定时间内移除并返回队头元素，如果队列为空则阻塞指定时间</span></span><br><span class="line">q.poll() <span class="comment">// 尝试移除并返回队头元素（优先级最高的元素），如果队列为空则返回 null（非阻塞）</span></span><br><span class="line">q.peek() <span class="comment">// 返回队头元素但不移除它，如果队列为空则返回 null</span></span><br><span class="line">q.isEmpty() <span class="comment">// 判断队列是否为空</span></span><br><span class="line">q.size() <span class="comment">// 返回队列当前元素的数量</span></span><br><span class="line">q.clear() <span class="comment">// 清空队列中的所有元素</span></span><br><span class="line">q.drainTo(Collection&lt;? <span class="built_in">super</span> E&gt; c) <span class="comment">// 移除队列中的所有元素并将其添加到给定的集合 c 中</span></span><br></pre></td></tr></table></figure>

<h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p><strong>延迟队列</strong>：其元素只能在指定的延迟时间到期后才能被取出，队列中的每个元素都需要实现 <code>Delayed</code> 接口，并指定一个延迟时间。</p>
<p><strong>阻塞操作</strong>：它是一个线程安全的阻塞队列</p>
<p>​					当尝试取出队列中的元素时，如果元素尚未到期，调用者会被阻塞，直到有元素到期或者队列为空</p>
<p><strong>无界队列</strong>：可以不断插入元素，队列的容量仅受限于系统内存。当元素没有到期时，不会被移除，直到到期时间达到</p>
<p><strong>适用场景</strong>：适用于任务调度和延时事件处理的场景，例如处理定时任务或处理延迟消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;T&gt; q = <span class="keyword">new</span> <span class="title class_">DelayQueue</span>() <span class="comment">// 创建一个新的无界 DelayQueue，队列元素按延迟时间进行排序</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">q.put(E e) <span class="comment">// 将元素 e 插入队列，元素的延迟时间由 e 的 `getDelay()` 方法指定</span></span><br><span class="line">q.take() <span class="comment">// 移除并返回队头元素，只有当队头元素的延迟时间已到时才会返回，如果队列为空或元素尚未到期，则阻塞</span></span><br><span class="line">q.poll(<span class="type">long</span> timeout, TimeUnit unit) <span class="comment">// 尝试在指定时间内移除并返回队头元素，如果队列为空或队头元素尚未到期则阻塞指定时间</span></span><br><span class="line">q.poll() <span class="comment">// 尝试移除并返回队头元素，如果队列为空或队头元素尚未到期则返回 null（非阻塞）</span></span><br><span class="line">q.peek() <span class="comment">// 返回队头元素但不移除它，如果队列为空或队头元素尚未到期则返回 null</span></span><br><span class="line">q.isEmpty() <span class="comment">// 判断队列是否为空</span></span><br><span class="line">q.size() <span class="comment">// 返回队列当前元素的数量</span></span><br><span class="line">q.clear() <span class="comment">// 清空队列中的所有元素</span></span><br></pre></td></tr></table></figure>

<h1 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h1><h3 id="计数器锁-CountDownLatch"><a href="#计数器锁-CountDownLatch" class="headerlink" title="计数器锁 CountDownLatch"></a>计数器锁 CountDownLatch</h3><blockquote>
<p>允许一个或多个线程，直到其他线程都完成工作后，才会继续执行</p>
</blockquote>
<p><strong>需求</strong>：</p>
<ul>
<li>有<code>20</code>个计算任务，需要先将这些任务的结果全部计算出来，每个任务的执行时间未知</li>
<li>当所有任务结束之后，立即整合统计最终结果</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">20</span>); <span class="comment">// 创建一个初始值为 20 的计数器锁</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (<span class="number">2000</span> * <span class="keyword">new</span> <span class="title class_">Random</span>().nextDouble()));</span><br><span class="line">                    System.out.println(<span class="string">&quot;子任务&quot;</span> + finalI + <span class="string">&quot;执行完成！&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                latch.countDown(); <span class="comment">// 每执行一次计数器都会 -1</span></span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latch.await(); <span class="comment">// 开始等待所有的线程完成，当计数器为0时，恢复运行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;所有子任务都完成！！！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意这个计数器只能使用一次，用完只能重新创一个，没有重置的说法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">子任务11执行完成！</span><br><span class="line">子任务5执行完成！</span><br><span class="line">子任务14执行完成！</span><br><span class="line">子任务17执行完成！</span><br><span class="line">子任务4执行完成！</span><br><span class="line">子任务8执行完成！</span><br><span class="line">子任务7执行完成！</span><br><span class="line">子任务9执行完成！</span><br><span class="line">子任务2执行完成！</span><br><span class="line">子任务19执行完成！</span><br><span class="line">子任务1执行完成！</span><br><span class="line">子任务15执行完成！</span><br><span class="line">子任务18执行完成！</span><br><span class="line">子任务12执行完成！</span><br><span class="line">子任务6执行完成！</span><br><span class="line">子任务0执行完成！</span><br><span class="line">子任务10执行完成！</span><br><span class="line">子任务16执行完成！</span><br><span class="line">子任务3执行完成！</span><br><span class="line">子任务13执行完成！</span><br><span class="line">所有子任务都完成！！！</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 0</span><br></pre></td></tr></table></figure>

<h3 id="循环屏障-CyclicBarrier"><a href="#循环屏障-CyclicBarrier" class="headerlink" title="循环屏障 CyclicBarrier"></a>循环屏障 CyclicBarrier</h3><blockquote>
<p>允许一组线程互相等待，直到所有线程都到达某个公共的同步点后，才会继续执行</p>
</blockquote>
<p><strong>需求</strong>：</p>
<p>假如现在游戏房间为空，但是游戏开始需要<code>5</code>人</p>
<p>所以必须集齐<code>5</code>人到来之后才能开始游戏，并且保证游戏开始时所有玩家都是同时进入</p>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>, <span class="comment">// 创建一个初始值为 5 的循环屏障</span></span><br><span class="line">                () -&gt; System.out.println(<span class="string">&quot;飞机马上就要起飞了，各位特种兵请准备！&quot;</span>)); <span class="comment">// 人等够之后执行的任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (<span class="number">2000</span> * <span class="keyword">new</span> <span class="title class_">Random</span>().nextDouble()));</span><br><span class="line">                    System.out.println(<span class="string">&quot;玩家 &quot;</span> + finalI + <span class="string">&quot; 进入房间进行等待... (&quot;</span> + (barrier.getNumberWaiting() + <span class="number">1</span>) + <span class="string">&quot; / 10 )&quot;</span>);</span><br><span class="line">                    barrier.await(); <span class="comment">// 调用 await 方法进行等待，直到等待的线程足够多为止（可循环）</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;玩家 &quot;</span> + finalI + <span class="string">&quot; 进入游戏！&quot;</span>); <span class="comment">// 开始游戏</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">玩家 4 进入房间进行等待... (1 / 10 )</span><br><span class="line">玩家 9 进入房间进行等待... (2 / 10 )</span><br><span class="line">玩家 5 进入房间进行等待... (3 / 10 )</span><br><span class="line">玩家 3 进入房间进行等待... (4 / 10 )</span><br><span class="line">玩家 2 进入房间进行等待... (5 / 10 )</span><br><span class="line">飞机马上就要起飞了，各位特种兵请准备！</span><br><span class="line">玩家 2 进入游戏！</span><br><span class="line">玩家 5 进入游戏！</span><br><span class="line">玩家 3 进入游戏！</span><br><span class="line">玩家 9 进入游戏！</span><br><span class="line">玩家 4 进入游戏！</span><br><span class="line">玩家 6 进入房间进行等待... (1 / 10 )</span><br><span class="line">玩家 8 进入房间进行等待... (2 / 10 )</span><br><span class="line">玩家 7 进入房间进行等待... (3 / 10 )</span><br><span class="line">玩家 1 进入房间进行等待... (4 / 10 )</span><br><span class="line">玩家 0 进入房间进行等待... (5 / 10 )</span><br><span class="line">飞机马上就要起飞了，各位特种兵请准备！</span><br><span class="line">玩家 6 进入游戏！</span><br><span class="line">玩家 0 进入游戏！</span><br><span class="line">玩家 8 进入游戏！</span><br><span class="line">玩家 1 进入游戏！</span><br><span class="line">玩家 7 进入游戏！</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 0</span><br></pre></td></tr></table></figure>

<h3 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h3><blockquote>
<p>用于控制多个线程对共享资源的访问，它通过维护一个许可计数来管理并发访问</p>
<p>可以被用来限制同时访问特定资源的线程数，从而避免资源竞争和过度的线程争用</p>
</blockquote>
<p><strong>需求</strong>：</p>
<p>现在有<code>10</code>个线程同时进行任务，任务要求是执行某个方法</p>
<p>但是这个方法最多同时只能由<code>5</code>个线程执行</p>
<p><strong>示例</strong>：             </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>); <span class="comment">// 信号量为 5</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">// 10 个线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>(semaphore, i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123; <span class="comment">// 任务类</span></span><br><span class="line">        <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> threadId;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(Semaphore semaphore, <span class="type">int</span> threadId)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.semaphore = semaphore;</span><br><span class="line">            <span class="built_in">this</span>.threadId = threadId;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire(); <span class="comment">// 获取信号量</span></span><br><span class="line">                System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 开始执行任务...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 获取到信号量，开始执行任务</span></span><br><span class="line">                semaphore.release(); <span class="comment">// 执行完毕，释放信号量</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">线程 1 开始执行任务...</span><br><span class="line">线程 3 开始执行任务...</span><br><span class="line">线程 2 开始执行任务...</span><br><span class="line">线程 6 开始执行任务...</span><br><span class="line">线程 0 开始执行任务...</span><br><span class="line">线程 4 开始执行任务...</span><br><span class="line">线程 5 开始执行任务...</span><br><span class="line">线程 9 开始执行任务...</span><br><span class="line">线程 7 开始执行任务...</span><br><span class="line">线程 8 开始执行任务...</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 0</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">semaphore.availablePermits() <span class="comment">// 剩余许可证数量</span></span><br><span class="line">semaphore.hasQueuedThreads() <span class="comment">// 是否存在线程等待许可证</span></span><br><span class="line">semaphore.getQueueLength() <span class="comment">// 等待许可证线程数量</span></span><br><span class="line">    </span><br><span class="line">semaphore.drainPermits() <span class="comment">// 直接回收掉剩余的许可证</span></span><br></pre></td></tr></table></figure>

<h3 id="数据交换-Exchanger"><a href="#数据交换-Exchanger" class="headerlink" title="数据交换 Exchanger"></a>数据交换 Exchanger</h3><blockquote>
<p>用于线程之间的数据交换</p>
</blockquote>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;收到主线程传递的交换数据：&quot;</span> + exchanger.exchange(<span class="string">&quot;AAA&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        System.out.println(<span class="string">&quot;收到子线程传递的交换数据：&quot;</span> + exchanger.exchange(<span class="string">&quot;BBB&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">收到主线程传递的交换数据：BBB</span><br><span class="line">收到子线程传递的交换数据：AAA</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 0</span><br></pre></td></tr></table></figure>

<h3 id="Fork-Join-框架"><a href="#Fork-Join-框架" class="headerlink" title="Fork&#x2F;Join 框架"></a>Fork&#x2F;Join 框架</h3><p>在 JDK7 时，出现了一个新的框架用于并行执行任务</p>
<p>它的目的是为了把大型任务拆分为多个小任务，最后汇总多个小任务的结果，得到整大任务的结果</p>
<p>并且这些小任务都是同时在进行，大大提高运算效率</p>
<blockquote>
<p>Fork 就是拆分，Join 就是合并</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/13%20JavaJUC%20%E5%A4%9A%E7%BA%BF%E7%A8%8B-17.jpg"></p>
<p>它不仅仅只是拆分任务并使用多线程，而且还可以利用工作窃取算法，提高线程的利用率</p>
<blockquote>
<p><strong>工作窃取算法：</strong> </p>
<p>指某个线程从其他队列里窃取任务来执行</p>
<p>一个大任务分割为若干个互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应</p>
<p>但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务待处理</p>
<p>干完活的线程与其等着，不如帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/13%20JavaJUC%20%E5%A4%9A%E7%BA%BF%E7%A8%8B-18.jpg"></p>
<p><strong>需求</strong>：</p>
<p>计算<code>1-1000</code>的和</p>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;求和结果：&quot;</span> + pool.submit(<span class="keyword">new</span> <span class="title class_">SubTask</span>(<span class="number">1</span>, <span class="number">1000</span>)).get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SubTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123; <span class="comment">// 继承 RecursiveTask，这样才可以作为一个任务，泛型就是计算结果类型</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> start, end; <span class="comment">// 范围</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SubTask</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.start = start;</span><br><span class="line">            <span class="built_in">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(end - start &gt; <span class="number">125</span>) &#123; <span class="comment">// 每个任务最多计算 125 个数的和，大于继续拆分</span></span><br><span class="line">                <span class="type">SubTask</span> <span class="variable">subTask1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubTask</span>(start, (end + start) / <span class="number">2</span>);</span><br><span class="line">                subTask1.fork(); <span class="comment">// 继续划分子任务执行</span></span><br><span class="line">                <span class="type">SubTask</span> <span class="variable">subTask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubTask</span>((end + start) / <span class="number">2</span> + <span class="number">1</span>, end);</span><br><span class="line">                subTask2.fork(); <span class="comment">// 继续划分子任务执行</span></span><br><span class="line">                <span class="keyword">return</span> subTask1.join() + subTask2.join(); <span class="comment">// 合并结果返回</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 小于就可以开始算了</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：开始计算 &quot;</span> + start + <span class="string">&quot; - &quot;</span> + end + <span class="string">&quot; 的值!&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">                    res += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool-1-worker-5：开始计算 251 - 375 的值!</span><br><span class="line">ForkJoinPool-1-worker-1：开始计算 1 - 125 的值!</span><br><span class="line">ForkJoinPool-1-worker-4：开始计算 126 - 250 的值!</span><br><span class="line">ForkJoinPool-1-worker-8：开始计算 751 - 875 的值!</span><br><span class="line">ForkJoinPool-1-worker-2：开始计算 501 - 625 的值!</span><br><span class="line">ForkJoinPool-1-worker-6：开始计算 376 - 500 的值!</span><br><span class="line">ForkJoinPool-1-worker-9：开始计算 626 - 750 的值!</span><br><span class="line">ForkJoinPool-1-worker-10：开始计算 876 - 1000 的值!</span><br><span class="line">求和结果：500500</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 0</span><br></pre></td></tr></table></figure>

<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>将已创建的线程复用，利用池化技术，就像数据库连接池一样</p>
<p>然后反复地使用这些线程，而不对它们进行销毁</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/13%20JavaJUC%20%E5%A4%9A%E7%BA%BF%E7%A8%8B-19.jpg"></p>
<h3 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.acc = System.getSecurityManager() == <span class="literal">null</span> ?</span><br><span class="line">            <span class="literal">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li><p><code>corePoolSize</code>：<strong>核心线程池大小</strong></p>
<p>每向线程池提交一个多线程任务时，都会创建一个新的<code>核心线程</code></p>
<p>无论是否存在其他空闲线程，直到到达核心线程池大小为止，之后会尝试复用线程资源</p>
</li>
<li><p><code>maximumPoolSize</code>：<strong>最大线程池大小</strong></p>
<p>当目前线程池中所有的线程都处于运行状态，并且等待队列已满</p>
<p>那么就会直接尝试继续创建新的<code>非核心线程</code>运行，但是不能超过最大线程池大小</p>
</li>
<li><p><code>keepAliveTime</code>：<strong>线程最大空闲时间</strong></p>
<p>当一个<code>非核心线程</code>空闲超过一定时间，会自动销毁</p>
</li>
<li><p><code>unit</code>：<strong>线程最大空闲时间的时间单位</strong></p>
</li>
<li><p><code>workQueue</code>：<strong>线程等待队列</strong></p>
<p>当线程池中核心线程数已满时，就会将任务暂时存到等待队列中，直到有线程资源可用为止</p>
</li>
<li><p><code>threadFactory</code>：<strong>线程创建工厂</strong></p>
<p>可以自定义线程池中线程的创建过程</p>
</li>
<li><p><code>handler</code>：<strong>拒绝策略</strong></p>
<p>当等待队列和线程池都没有空间时，来了个新的多线程任务，这时就会根据当前设定的拒绝策略进行处理</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">拒绝策略</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>AbortPolicy</code></td>
<td align="center">直接抛异常（默认）</td>
</tr>
<tr>
<td align="center"><code>CallerRunsPolicy</code></td>
<td align="center">直接让提交任务的线程运行这个任务</td>
</tr>
<tr>
<td align="center"><code>DiscardOldestPolicy</code></td>
<td align="center">丢弃队列中最近的一个任务，替换为当前任务</td>
</tr>
<tr>
<td align="center"><code>DiscardPolicy</code></td>
<td align="center">什么也不用做</td>
</tr>
</tbody></table>
<p><strong>线程池执行任务的特性</strong>：</p>
<ul>
<li><strong>CPU 密集型：</strong> 主要是执行计算任务。线程池大小一般配置为 CPU 的核心数</li>
<li><strong>IO 密集型：</strong> 主要是进行 IO 操作。线程池大小一般配置为 CPU 的核心数的 2 倍</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="comment">// 2 个核心线程，最大线程数为 4 个</span></span><br><span class="line">                        <span class="number">3</span>, TimeUnit.SECONDS, <span class="comment">// 最大空闲时间为 3 秒</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2</span>)); <span class="comment">// 这里使用容量为 2 的阻塞队列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123; <span class="comment">// 开始 6 个任务</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始执行！&quot;</span> + finalI);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 已结束！&quot;</span> + finalI);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;线程池中线程数量：&quot;</span> + executor.getPoolSize()); <span class="comment">// 查看当前线程池中的线程数量</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>); <span class="comment">// 等到超过空闲时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程池中线程数量：&quot;</span> + executor.getPoolSize());</span><br><span class="line"></span><br><span class="line">        executor.shutdownNow(); <span class="comment">// 使用完线程池记得关闭，不然程序不会结束，它会取消所有等待中的任务以及试图中断正在执行的任务，关闭后，无法再提交任务，一律拒绝</span></span><br><span class="line">        <span class="comment">// executor.shutdown(); // 同样可以关闭，但是会执行完等待队列中的任务再关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-3 开始执行！4</span><br><span class="line">pool-1-thread-2 开始执行！1</span><br><span class="line">pool-1-thread-4 开始执行！5</span><br><span class="line">pool-1-thread-1 开始执行！0</span><br><span class="line">pool-1-thread-2 已结束！1</span><br><span class="line">pool-1-thread-4 已结束！5</span><br><span class="line">pool-1-thread-3 已结束！4</span><br><span class="line">pool-1-thread-2 开始执行！2</span><br><span class="line">pool-1-thread-4 开始执行！3</span><br><span class="line">pool-1-thread-1 已结束！0</span><br><span class="line">线程池中线程数量：4</span><br><span class="line">pool-1-thread-2 已结束！2</span><br><span class="line">pool-1-thread-4 已结束！3</span><br><span class="line">线程池中线程数量：2</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 0</span><br></pre></td></tr></table></figure>

<p>除了使用官方提供的 4 种拒绝策略之外，还可以使用自定义的策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">4</span>,</span><br><span class="line">                <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">                (r, executor1) -&gt; &#123; <span class="comment">// 实现一个就在当前线程执行的策略</span></span><br><span class="line">                    r.run(); <span class="comment">// 直接运行</span></span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>

<p>还可以自行决定如何创建新的线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">4</span>,</span><br><span class="line">                        <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;我的自定义线程 - &quot;</span> + counter++);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            executor.execute(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：开始执行！&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">我的自定义线程 - 0：开始执行！</span><br><span class="line">我的自定义线程 - 3：开始执行！</span><br><span class="line">我的自定义线程 - 1：开始执行！</span><br><span class="line">我的自定义线程 - 2：开始执行！</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 130</span><br></pre></td></tr></table></figure>

<p>如果任务在运行过程中出现异常了，再次提交新的任务，执行的线程是一个新的线程了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="comment">// 最大容量和核心容量锁定为 1</span></span><br><span class="line">                <span class="number">0</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;());</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;我是异常！&quot;</span>); <span class="comment">// 抛出异常</span></span><br><span class="line">        &#125;);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1</span><br><span class="line">Exception in thread &quot;pool-1-thread-1&quot; java.lang.RuntimeException: 我是异常！</span><br><span class="line">	at Main.lambda$main$0(Main.java:16)</span><br><span class="line">	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)</span><br><span class="line">	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)</span><br><span class="line">	at java.base/java.lang.Thread.run(Thread.java:840)</span><br><span class="line">pool-1-thread-2</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 130</span><br></pre></td></tr></table></figure>

<p>可以使用<code>Executors</code>工具类来快速创建线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(值); <span class="comment">// 创建一个固定容量的线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor(); <span class="comment">// 创建一个只有一个线程的线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool(); <span class="comment">// 会根据需要无限制创建新线程的线程池</span></span><br></pre></td></tr></table></figure>

<h3 id="执行带返回值的任务"><a href="#执行带返回值的任务" class="headerlink" title="执行带返回值的任务"></a>执行带返回值的任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        Future&lt;String&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;AAA&quot;</span>;</span><br><span class="line">        &#125;); <span class="comment">// 使用 submit 提交任务，会返回一个 Future 对象</span></span><br><span class="line">        System.out.println(future.get()); <span class="comment">// 如果任务未完成，get 会被阻塞，任务完成返回执行结果的返回值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;任务是否执行完成：&quot;</span> + future.isDone());</span><br><span class="line">        System.out.println(<span class="string">&quot;任务是否被取消：&quot;</span> + future.isCancelled());</span><br><span class="line">        <span class="comment">// System.out.println(future.cancel(true)); // 取消任务</span></span><br><span class="line">        <span class="comment">// System.out.println(&quot;任务是否被取消：&quot; + future.isCancelled());</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AAA</span><br><span class="line">任务是否执行完成：true</span><br><span class="line">任务是否被取消：false</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 0</span><br></pre></td></tr></table></figure>

<h3 id="执行定时任务"><a href="#执行定时任务" class="headerlink" title="执行定时任务"></a>执行定时任务</h3><p>JDK5 之后，可以使用<code>ScheduledThreadPoolExecutor</code>来提交定时任务，它继承自<code>ThreadPoolExecutor</code></p>
<p>并且所有的构造方法都必须要求最大线程池容量为<code>Integer.MAX_VALUE</code>，并且都是采用的<code>DelayedWorkQueue</code>作为等待队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>); <span class="comment">// 核心线程数为 1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">executor.schedule(() -&gt; System.out.println(<span class="string">&quot;Hello World!&quot;</span>), <span class="number">3</span>, TimeUnit.SECONDS); <span class="comment">// 计划在 3 秒后执行</span></span><br><span class="line">executor.scheduleAtFixedRate(() -&gt; System.out.println(<span class="string">&quot;Hello World!&quot;</span>),</span><br><span class="line">        <span class="number">3</span>, <span class="number">1</span>, TimeUnit.SECONDS); <span class="comment">// 计划在 3 秒后执行，之后每隔一秒钟执行一次</span></span><br></pre></td></tr></table></figure>

<h3 id="线程池实现原理"><a href="#线程池实现原理" class="headerlink" title="线程池实现原理"></a>线程池实现原理</h3><h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>)); <span class="comment">// 用于同时保存线程池运行状态和线程数量</span></span><br><span class="line"><span class="comment">// 它是通过拆分 32 个 bit 位来保存数据的，前 3 位保存状态，后 29 位保存工作线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>; <span class="comment">// 29 位，线程数量位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span>   <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>; <span class="comment">// 计算得出最大容量（2^29-1）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">// 接收新任务，并等待执行队列中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS; <span class="comment">// 不接收新任务，但是依然等待执行队列中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">// 不接收新任务，也不执行队列中的任务，并且还要中断正在执行中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS; <span class="comment">// 所有的任务都已结束，线程数量为 0，即将完全关闭</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS; <span class="comment">// 完全关闭</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/13%20JavaJUC%20%E5%A4%9A%E7%BA%BF%E7%A8%8B-20.jpg"></p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span> &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125; <span class="comment">// 取运行状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span> &#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125; <span class="comment">// 取线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125; </span><br></pre></td></tr></table></figure>

<h4 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue; <span class="comment">// 指定的阻塞队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(); <span class="comment">// 如果任务为 null，直接抛出空指针异常</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get(); <span class="comment">// 获取 ctl 的值</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; <span class="comment">// 判断工作线程数量是否小于核心线程数</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>)) <span class="comment">// 直接加新的线程执行即可</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get(); <span class="comment">// 如果线程添加失败（有可能其他线程也在对线程池进行操作），那就更新一下 c 的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; <span class="comment">// 如果当前线程池是运行状态，那就向阻塞队列中添加一个新的等待任务</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get(); <span class="comment">// 再次获取 ctl 的值</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command)) <span class="comment">// 这里是再次确认当前线程池是否关闭，如果添加等待任务后线程池关闭了，那就把刚刚加进去任务的又拿出来</span></span><br><span class="line">            reject(command); <span class="comment">// 然后直接拒绝当前任务的提交（会根据我们的拒绝策略决定如何进行拒绝操作）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) <span class="comment">// 如果这个时候线程池依然在运行状态，那么就检查一下当前工作线程数是否为 0，如果是那就直接添加新线程执行</span></span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>); <span class="comment">// 添加一个新的非核心线程，但是注意没添加任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>)) <span class="comment">// 这种情况要么就是线程池没有运行，要么就是队列满了，按照之前的规则，核心线程数已满且队列已满，那么会直接添加新的非核心线程，但是如果已经添加到最大数量，这里肯定是会失败的</span></span><br><span class="line">        reject(command); <span class="comment">// 拒绝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    retry: <span class="comment">// 标签</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get(); <span class="comment">// 获取 ctl 值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c); <span class="comment">// 解析当前的运行状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; <span class="comment">// 判断线程池是否处于非运行状态</span></span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="literal">null</span> &amp;&amp;   </span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果不是运行状态，判断线程是 SHUTDOWN 状态并且任务不为 null 、等待队列不为空，只要有其中一者不满足，直接返回 false，添加失败</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c); <span class="comment">// 解析当前的工作线程数量</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize)) <span class="comment">// 判断一下还装得下不，如果装得下，看看是核心线程还是非核心线程，如果是核心线程，不能大于核心线程数的限制，如果是非核心线程，不能大于最大线程数限制</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c)) <span class="comment">// CAS 自增线程计数，如果增加成功，任务完成，直接跳出继续</span></span><br><span class="line">                <span class="keyword">break</span> retry; <span class="comment">// 直接跳出最外层循环</span></span><br><span class="line">            c = ctl.get(); <span class="comment">// 如果 CAS 失败，更新一下 c 的值</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs) <span class="comment">// 如果 CAS 失败的原因是因为线程池状态和一开始的不一样了，那么就重新从外层循环再来一次</span></span><br><span class="line">                <span class="keyword">continue</span> retry; <span class="comment">// 直接从最外层循环继续</span></span><br><span class="line">            <span class="comment">// 如果是其他原因导致的 CAS 失败，那只可能是其他线程同时在自增，所以重新再来一次内层循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 线程计数自增完了，接着就是添加新的工作线程了</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 工作线程是否已启动</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 工作线程是否已添加</span></span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 暂时理解为工作线程</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask); <span class="comment">// 创建新的工作线程</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread; <span class="comment">// 传入提交的任务到工作线程中封装的 Thread 对象</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            mainLock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get()); <span class="comment">// 获取当前线程的运行状态</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123; <span class="comment">// 只有当前线程池是正在运行状态，或是 SHUTDOWN 状态且firstTask 为空，那么就继续</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// 检查一下线程是否正在运行状态</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>(); <span class="comment">// 如果是那肯定是不能运行这个任务的</span></span><br><span class="line">                    workers.add(w); <span class="comment">// 直接将新创建的 Work 丢进 workers 集合中</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size(); <span class="comment">// 查看当前 workers 的大小</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize) <span class="comment">// 记录线程池运行以来，历史上的最多线程数</span></span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="literal">true</span>; <span class="comment">// 工作线程已添加</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start(); <span class="comment">// 启动线程</span></span><br><span class="line">                workerStarted = <span class="literal">true</span>; <span class="comment">// 工作线程已启动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!workerStarted) <span class="comment">// 如果线程在上面的启动过程中失败了</span></span><br><span class="line">            addWorkerFailed(w); <span class="comment">// 将 w 移出 workers 并将计数器 -1，最后如果线程池是终止状态，会尝试加速终止线程池</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted; <span class="comment">// 返回是否成功启动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Thread thread; <span class="comment">// 主线程</span></span><br><span class="line">    Runnable firstTask; <span class="comment">// 要执行的第一个任务</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> completedTasks; <span class="comment">// 记录这个线程完成了多少个任务</span></span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// 执行 Task 之前不让中断，将 AQS 的 state 设定为 -1</span></span><br><span class="line">        <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>); <span class="comment">// 通过预定义或是自定义的线程工厂创建线程</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        runWorker(<span class="built_in">this</span>); <span class="comment">// 真正开始执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123; <span class="comment">// 是否已加锁</span></span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread(); <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask; <span class="comment">// 取出要执行的任务</span></span><br><span class="line">    w.firstTask = <span class="literal">null</span>; <span class="comment">// 然后把 Worker 中的任务设定为 null</span></span><br><span class="line">    w.unlock(); <span class="comment">// 因为一开始为 -1，这里是通过 unlock 操作将其修改回 0，只有 state 大于等于 0 才能响应中断</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 只要任务不为 null，或是任务为空但是可以从等待队列中取出任务不为空，那么就开始执行这个任务，注意这里是无限循环，也就是说如果当前没有任务了，那么会在 getTask 方法中卡住，因为要从阻塞队列中等着取任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            w.lock(); <span class="comment">// 对当前 Worker 加锁，这里其实并不是防其他线程，而是在 shutdown 时保护此任务的运行</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 由于线程池在 STOP 状态及以上会禁止新线程加入并且中断正在进行的线程</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) || <span class="comment">// 只要线程池是 STOP 及以上的状态，那肯定是不能开始新任务的</span></span><br><span class="line">                (Thread.interrupted() &amp;&amp; <span class="comment">// 线程是否已经被打上中断标记并且线程一定是 STOP 及以上</span></span><br><span class="line">                runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted()) <span class="comment">// 再次确保线程没有被打上中断标记</span></span><br><span class="line">                wt.interrupt(); <span class="comment">// 打中断标记</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task); <span class="comment">// 开始之前的准备工作，这里暂时没有实现</span></span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run(); <span class="comment">// 开始执行任务</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown); <span class="comment">// 执行之后的工作，也没实现</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="literal">null</span>; <span class="comment">// 任务已完成，不需要了</span></span><br><span class="line">                w.completedTasks++; <span class="comment">// 任务完成数++</span></span><br><span class="line">                w.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果能走到这一步，那说明上面的循环肯定是跳出了，也就是说这个 Worker 可以丢弃了</span></span><br><span class="line">        <span class="comment">// 所以这里会直接将 Worker 从 workers 里删除掉</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;              </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123; <span class="comment">// 从阻塞队列里获取任务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get(); <span class="comment">// 获取 ctl</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c); <span class="comment">// 解析线程池运行状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; <span class="comment">// 判断是不是没有必要再执行等待队列中的任务了，也就是处于关闭线程池的状态了</span></span><br><span class="line">            decrementWorkerCount(); <span class="comment">// 直接减少一个工作线程数量</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 返回 null，这样上面的 runWorker 就直接结束了，下同</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c); <span class="comment">// 如果线程池运行正常，那就获取当前的工作线程数量</span></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize; <span class="comment">// 如果线程数大于核心线程数或是允许核心线程等待超时，那么就标记为可超时的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 超时或 maximumPoolSize 在运行期间被修改了，并且线程数大于 1 或等待队列为空，那也是不能获取到任务的</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c)) <span class="comment">// 如果 CAS 减少工作线程成功</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 否则开启下一轮循环</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : <span class="comment">// 如果可超时，那么最多等到超时时间</span></span><br><span class="line">                workQueue.take(); <span class="comment">// 如果不可超时，那就一直等着拿任务</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>) <span class="comment">// 如果成功拿到任务，ok，返回</span></span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="literal">true</span>; <span class="comment">// 否则就是超时了，下一轮循环将直接返回 null</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="literal">false</span>; <span class="comment">// 发生中断异常，重置超时标记</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开下一轮循环吧</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h4><h5 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123; <span class="comment">// 关闭线程池，但是会继续将等待队列中的线程执行完成后再关闭</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess(); <span class="comment">// 判断是否有权限终止</span></span><br><span class="line">        advanceRunState(SHUTDOWN); <span class="comment">// CAS 将线程池运行状态改为 SHUTDOWN 状态</span></span><br><span class="line">        interruptIdleWorkers(); <span class="comment">// 让闲着的线程（比如正在等新的任务）中断，但是并不会影响正在运行的线程</span></span><br><span class="line">        onShutdown(); <span class="comment">// 给 ScheduledThreadPoolExecutor 提供的钩子方法，就是等 ScheduledThreadPoolExecutor 去实现的，当前类没有实现</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate(); <span class="comment">// 最后尝试终止线程池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">advanceRunState</span><span class="params">(<span class="type">int</span> targetState)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get(); <span class="comment">// 获取 ctl</span></span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, targetState) || <span class="comment">// 是否大于等于指定的状态</span></span><br><span class="line">            ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c)))) <span class="comment">// CAS 设置 ctl 的值</span></span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">interruptIdleWorkers</span><span class="params">(<span class="type">boolean</span> onlyOne)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread; <span class="comment">// 拿到 Worker 中的线程</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123; <span class="comment">// 先判断一下线程是不是没有被中断然后尝试加锁，但是通过前面的 runWorker() 源代码得知，开始之后是让 Worker 加了锁的，所以如果线程还在执行任务，那么这里肯定会 false</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt(); <span class="comment">// 如果走到这里，那么说明线程肯定是一个闲着的线程，直接给中断吧</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne) <span class="comment">// 如果只针对一个 Worker，那么就结束循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123; <span class="comment">// 关闭线程池，不仅不允许新的任务到来，也不会再执行等待队列的线程，而且会终止正在执行的线程</span></span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP); <span class="comment">// 直接设定为 STOP 状态</span></span><br><span class="line">        interruptWorkers(); <span class="comment">// 直接中断所有工作线程</span></span><br><span class="line">        tasks = drainQueue(); <span class="comment">// 取出仍处于阻塞队列中的线程</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks; <span class="comment">// 最后返回还没开始的任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">interruptWorkers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) <span class="comment">// 遍历所有 Worker</span></span><br><span class="line">            w.interruptIfStarted(); <span class="comment">// 无差别对待，一律加中断标记</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryTerminate</span><span class="params">()</span> &#123; <span class="comment">// 完完全全终止掉一个线程池</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get(); <span class="comment">// 获取一下 ctl 的值</span></span><br><span class="line">      	<span class="comment">// 只要是正在运行或是线程池基本上关闭了或是处于 SHUTDOWN 状态且工作队列不为空，那么这时还不能关闭线程池</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 走到这里，要么处于 SHUTDOWN 状态且等待队列为空或是 STOP 状态</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// 如果工作线程数不是 0，这里也会中断空闲状态下的线程</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE); <span class="comment">// 这里最多只中断一个空闲线程，然后返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 走到这里，工作线程也为空了，可以终止线程池了</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123; <span class="comment">// 先 CAS 将状态设定为 TIDYING 表示基本终止，正在做最后的操作</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    terminated(); <span class="comment">// 终止，暂时没有实现</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>)); <span class="comment">// 最后将状态设定为 TERMINATED，表示线程池结束了</span></span><br><span class="line">                    termination.signalAll(); <span class="comment">// 如果有线程调用了 awaitTermination 方法，会等待当前线程池终止，到这里差不多就可以唤醒了</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 CAS 失败，会直接进下一轮循环重新判断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://gitee.com/kokoachino/picture-bed/raw/master/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/head.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://gitee.com/kokoachino/picture-bed/raw/master/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/head.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">星开祈灵</div><div class="post-copyright__author_desc">( ´•̥̥̥ω•̥̥̥` )</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://kokoachino.github.io/2024/11/16/13%20JavaJUC%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://kokoachino.github.io/2024/11/16/13%20JavaJUC%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/')">JavaJUC 多线程</span></a></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://KokoaChino.github.io" target="_blank">星开祈灵的个人博客</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Java/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Java<span class="tagsPageCount">9</span></a><a class="post-meta__box__tags" href="/tags/%E9%94%81/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>锁<span class="tagsPageCount">4</span></a><a class="post-meta__box__tags" href="/tags/JUC/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>JUC<span class="tagsPageCount">1</span></a><a class="post-meta__box__tags" href="/tags/volatile/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>volatile<span class="tagsPageCount">1</span></a><a class="post-meta__box__tags" href="/tags/AQS/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>AQS<span class="tagsPageCount">1</span></a><a class="post-meta__box__tags" href="/tags/%E5%8E%9F%E5%AD%90%E7%B1%BB/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>原子类<span class="tagsPageCount">1</span></a><a class="post-meta__box__tags" href="/tags/%E5%B9%B6%E5%8F%91/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>并发<span class="tagsPageCount">1</span></a><a class="post-meta__box__tags" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>线程池<span class="tagsPageCount">1</span></a></div></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/11/01/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://gitee.com/kokoachino/picture-bed/raw/master/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87.jpg?_r_=eb731b2e-9028-4489-94ca-8ae7eab745d5" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JavaJVM 虚拟机</div></div></a></div><div class="next-post pull-right"><a href="/2024/12/05/03%20Python%20%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://gitee.com/kokoachino/picture-bed/raw/master/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87.jpg?_r_=3845718d-b398-fd4b-e1ed-05c3918ba169" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Python 数学建模基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2023/07/12/01%20JavaSE/" title="JavaSE"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://gitee.com/kokoachino/picture-bed/raw/master/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87.jpg?_r_=86b497bf-c817-03b8-11c3-92bf1525deb5" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-07-12</div><div class="title">JavaSE</div></div></a></div><div><a href="/2023/10/10/02%20JavaSE%20%E6%96%B0%E7%89%B9%E6%80%A7/" title="JavaSE 新特性"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://gitee.com/kokoachino/picture-bed/raw/master/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87.jpg?_r_=fe40420e-0920-133a-4c3d-8b4f487af0fa" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-10</div><div class="title">JavaSE 新特性</div></div></a></div><div><a href="/2024/02/01/04%20Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="Java 设计模式"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://gitee.com/kokoachino/picture-bed/raw/master/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87.jpg?_r_=f694a06c-6328-fdd4-844b-14f2bae98913" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-02-01</div><div class="title">Java 设计模式</div></div></a></div><div><a href="/2024/06/01/06%20JavaWeb%20%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" title="JavaWeb 后端开发"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://gitee.com/kokoachino/picture-bed/raw/master/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87.jpg?_r_=6795ba84-9f70-294c-2a6c-4fc94d0a35f1" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-06-01</div><div class="title">JavaWeb 后端开发</div></div></a></div><div><a href="/2024/04/20/05%20JavaGUI%20%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BC%80%E5%8F%91/" title="JavaGUI 可视化开发"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://gitee.com/kokoachino/picture-bed/raw/master/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87.jpg?_r_=419018ea-5cf4-a90e-5a43-3e4d71dd716f" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-04-20</div><div class="title">JavaGUI 可视化开发</div></div></a></div><div><a href="/2024/11/01/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="JavaJVM 虚拟机"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://gitee.com/kokoachino/picture-bed/raw/master/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87.jpg?_r_=eb731b2e-9028-4489-94ca-8ae7eab745d5" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-11-01</div><div class="title">JavaJVM 虚拟机</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">锁机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">1.0.1.</span> <span class="toc-text">重量级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">1.0.2.</span> <span class="toc-text">轻量级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">自旋锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">1.0.3.</span> <span class="toc-text">偏向锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4%E5%92%8C%E9%94%81%E7%B2%97%E5%8C%96"><span class="toc-number">1.0.4.</span> <span class="toc-text">锁消除和锁粗化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-number">1.0.4.1.</span> <span class="toc-text">锁消除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96"><span class="toc-number">1.0.4.2.</span> <span class="toc-text">锁粗化</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JMM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">JMM 内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">2.0.1.</span> <span class="toc-text">重排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.0.2.</span> <span class="toc-text">volatile 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#happens-before-%E5%8E%9F%E5%88%99"><span class="toc-number">2.0.3.</span> <span class="toc-text">happens-before 原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9"><span class="toc-number">2.0.3.1.</span> <span class="toc-text">关键点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%A7%84%E5%88%99"><span class="toc-number">2.0.3.2.</span> <span class="toc-text">常见规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">2.0.3.3.</span> <span class="toc-text">作用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81%E6%A1%86%E6%9E%B6"><span class="toc-number">3.</span> <span class="toc-text">锁框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock"><span class="toc-number">3.1.</span> <span class="toc-text">Lock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Condition"><span class="toc-number">3.2.</span> <span class="toc-text">Condition</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TimeUnit"><span class="toc-number">3.3.</span> <span class="toc-text">TimeUnit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LockSupport"><span class="toc-number">3.4.</span> <span class="toc-text">LockSupport</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%8C%82%E8%B5%B7"><span class="toc-number">3.4.1.</span> <span class="toc-text">线程挂起</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%94%A4%E9%86%92"><span class="toc-number">3.4.2.</span> <span class="toc-text">线程唤醒</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">3.5.</span> <span class="toc-text">可重入锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">3.6.</span> <span class="toc-text">公平锁与非公平锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">3.7.</span> <span class="toc-text">读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E9%99%8D%E7%BA%A7%E5%92%8C%E9%94%81%E5%8D%87%E7%BA%A7"><span class="toc-number">3.7.1.</span> <span class="toc-text">锁降级和锁升级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8-AQS"><span class="toc-number">3.8.</span> <span class="toc-text">队列同步器 AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.8.1.</span> <span class="toc-text">底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AQS"><span class="toc-number">3.8.1.1.</span> <span class="toc-text">AQS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%8A%A0%E9%94%81"><span class="toc-number">3.8.1.2.</span> <span class="toc-text">公平锁加锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E8%A7%A3%E9%94%81"><span class="toc-number">3.8.1.3.</span> <span class="toc-text">公平锁解锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%80%E5%AE%9A%E5%85%AC%E5%B9%B3%E5%90%97%EF%BC%9F"><span class="toc-number">3.8.2.</span> <span class="toc-text">公平锁一定公平吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Condition-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.8.3.</span> <span class="toc-text">Condition 实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E8%A1%8C%E5%AE%9E%E7%8E%B0%E9%94%81%E7%B1%BB"><span class="toc-number">3.9.</span> <span class="toc-text">自行实现锁类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB"><span class="toc-number">4.0.1.</span> <span class="toc-text">基本数据类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicInteger"><span class="toc-number">4.0.1.1.</span> <span class="toc-text">AtomicInteger</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicLong"><span class="toc-number">4.0.1.2.</span> <span class="toc-text">AtomicLong</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicBoolean"><span class="toc-number">4.0.1.3.</span> <span class="toc-text">AtomicBoolean</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB"><span class="toc-number">4.0.2.</span> <span class="toc-text">数组类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicIntegerArray"><span class="toc-number">4.0.2.1.</span> <span class="toc-text">AtomicIntegerArray</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicLongArray"><span class="toc-number">4.0.2.2.</span> <span class="toc-text">AtomicLongArray</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicReferenceArray"><span class="toc-number">4.0.2.3.</span> <span class="toc-text">AtomicReferenceArray</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ABA-%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">4.0.3.</span> <span class="toc-text">ABA 问题及解决方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CopyOnWriteArrayList"><span class="toc-number">5.0.1.</span> <span class="toc-text">CopyOnWriteArrayList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">5.0.2.</span> <span class="toc-text">ConcurrentHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">5.0.3.</span> <span class="toc-text">阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayBlockingQueue"><span class="toc-number">5.0.3.1.</span> <span class="toc-text">ArrayBlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SynchronousQueue"><span class="toc-number">5.0.3.2.</span> <span class="toc-text">SynchronousQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedBlockingQueue"><span class="toc-number">5.0.3.3.</span> <span class="toc-text">LinkedBlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PriorityBlockingQueue"><span class="toc-number">5.0.3.4.</span> <span class="toc-text">PriorityBlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DelayQueue"><span class="toc-number">5.0.3.5.</span> <span class="toc-text">DelayQueue</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="toc-number">6.</span> <span class="toc-text">并发工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%99%A8%E9%94%81-CountDownLatch"><span class="toc-number">6.0.1.</span> <span class="toc-text">计数器锁 CountDownLatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%B1%8F%E9%9A%9C-CyclicBarrier"><span class="toc-number">6.0.2.</span> <span class="toc-text">循环屏障 CyclicBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F-Semaphore"><span class="toc-number">6.0.3.</span> <span class="toc-text">信号量 Semaphore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2-Exchanger"><span class="toc-number">6.0.4.</span> <span class="toc-text">数据交换 Exchanger</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fork-Join-%E6%A1%86%E6%9E%B6"><span class="toc-number">6.0.5.</span> <span class="toc-text">Fork&#x2F;Join 框架</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">7.0.1.</span> <span class="toc-text">线程池的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">7.0.1.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.0.1.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="toc-number">7.0.2.</span> <span class="toc-text">执行带返回值的任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">7.0.3.</span> <span class="toc-text">执行定时任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">7.0.4.</span> <span class="toc-text">线程池实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5"><span class="toc-number">7.0.4.1.</span> <span class="toc-text">字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">7.0.4.2.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1"><span class="toc-number">7.0.4.3.</span> <span class="toc-text">执行任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.0.4.4.</span> <span class="toc-text">关闭线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#shutdown"><span class="toc-number">7.0.4.4.1.</span> <span class="toc-text">shutdown</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#shutdownNow"><span class="toc-number">7.0.4.4.2.</span> <span class="toc-text">shutdownNow</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/24/07%20COLA%20%E6%9E%B6%E6%9E%84/" title="COLA 架构">COLA 架构</a><time datetime="2025-08-23T16:00:00.000Z" title="发表于 2025-08-24 00:00:00">2025-08-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/27/06%20Java%20%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/" title="Java 算法模版">Java 算法模版</a><time datetime="2025-06-26T16:00:00.000Z" title="发表于 2025-06-27 00:00:00">2025-06-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/15/05%20Python%20%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/" title="Python 算法模版">Python 算法模版</a><time datetime="2025-05-14T16:00:00.000Z" title="发表于 2025-05-15 00:00:00">2025-05-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/18/04%20C++%20%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/" title="C++ 语法基础">C++ 语法基础</a><time datetime="2025-04-17T16:00:00.000Z" title="发表于 2025-04-18 00:00:00">2025-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/05/03%20Python%20%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80/" title="Python 数学建模基础">Python 数学建模基础</a><time datetime="2024-12-04T16:00:00.000Z" title="发表于 2024-12-05 00:00:00">2024-12-05</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2024 - 2025 By <a class="footer-bar-link" href="/" title="星开祈灵" target="_blank">星开祈灵</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">134</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">4</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/API/" style="font-size: 0.88rem;">API<sup>1</sup></a><a href="/tags/CSS/" style="font-size: 0.88rem;">CSS<sup>1</sup></a><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 0.88rem;">HTML<sup>1</sup></a><a href="/tags/Java/" style="font-size: 0.88rem;">Java<sup>9</sup></a><a href="/tags/Lambda/" style="font-size: 0.88rem;">Lambda<sup>1</sup></a><a href="/tags/Matlab/" style="font-size: 0.88rem;">Matlab<sup>1</sup></a><a href="/tags/MySQL/" style="font-size: 0.88rem;">MySQL<sup>1</sup></a><a href="/tags/Optional/" style="font-size: 0.88rem;">Optional<sup>1</sup></a><a href="/tags/Stream-%E6%B5%81/" style="font-size: 0.88rem;">Stream 流<sup>1</sup></a><a href="/tags/Web/" style="font-size: 0.88rem;">Web<sup>6</sup></a><a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 0.88rem;">事务<sup>4</sup></a><a href="/tags/%E5%87%BD%E6%95%B0/" style="font-size: 0.88rem;">函数<sup>4</sup></a><a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/" style="font-size: 0.88rem;">函数式接口<sup>1</sup></a><a href="/tags/%E5%88%86%E6%94%AF/" style="font-size: 0.88rem;">分支<sup>1</sup></a><a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 0.88rem;">反射<sup>1</sup></a><a href="/tags/%E5%91%BD%E4%BB%A4/" style="font-size: 0.88rem;">命令<sup>2</sup></a><a href="/tags/%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/" style="font-size: 0.88rem;">图像绘制<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>1</sup></a><a href="/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/" style="font-size: 0.88rem;">存储过程<sup>1</sup></a><a href="/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/" style="font-size: 0.88rem;">定时器<sup>2</sup></a><a href="/tags/%E5%B1%9E%E6%80%A7/" style="font-size: 0.88rem;">属性<sup>2</sup></a><a href="/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8/" style="font-size: 0.88rem;">异常处理器<sup>1</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">数学<sup>2</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.88rem;">数据库<sup>2</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" style="font-size: 0.88rem;">数据类型<sup>4</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97/" style="font-size: 0.88rem;">数据统计与计算<sup>1</sup></a><a href="/tags/%E6%96%87%E4%BB%B6/" style="font-size: 0.88rem;">文件<sup>1</sup></a><a href="/tags/%E6%96%B0%E7%89%B9%E6%80%A7/" style="font-size: 0.88rem;">新特性<sup>1</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/" style="font-size: 0.88rem;">正则匹配<sup>1</sup></a><a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 0.88rem;">注解<sup>5</sup></a><a href="/tags/%E6%B8%B8%E6%A0%87/" style="font-size: 0.88rem;">游标<sup>1</sup></a><a href="/tags/%E7%AC%A6%E5%8F%B7%E5%AF%B9%E8%B1%A1/" style="font-size: 0.88rem;">符号对象<sup>1</sup></a><a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 0.88rem;">索引<sup>1</sup></a><a href="/tags/%E8%A7%86%E5%9B%BE/" style="font-size: 0.88rem;">视图<sup>1</sup></a><a href="/tags/%E8%A7%A6%E5%8F%91%E5%99%A8/" style="font-size: 0.88rem;">触发器<sup>1</sup></a><a href="/tags/%E8%AF%AD%E6%B3%95/" style="font-size: 0.88rem;">语法<sup>8</sup></a><a href="/tags/%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/" style="font-size: 0.88rem;">远程仓库<sup>1</sup></a><a href="/tags/%E9%80%89%E6%8B%A9%E5%99%A8/" style="font-size: 0.88rem;">选择器<sup>1</sup></a><a href="/tags/%E9%94%81/" style="font-size: 0.88rem;">锁<sup>4</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("11/1/2024 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2024 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 星开祈灵 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>