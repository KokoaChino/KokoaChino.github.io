<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>JavaJVM 虚拟机 | 星开祈灵的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Java, JVM, JNI, JRE, 垃圾回收机制, 引用类型, 类与类加载, 内存管理">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaJVM 虚拟机">
<meta property="og:url" content="https://kokoachino.github.io/1970/01/12/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/index.html">
<meta property="og:site_name" content="星开祈灵的个人博客">
<meta property="og:description" content="Java, JVM, JNI, JRE, 垃圾回收机制, 引用类型, 类与类加载, 内存管理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-1.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-2.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-3.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-4.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-48.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-5.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-6.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-7.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-8.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-9.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-10.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-11.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-12.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-13.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-14.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-15.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-16.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-17.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-18.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-19.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-20.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-21.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-22.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-23.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-24.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-25.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-26.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-27.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-28.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-29.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-30.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-31.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-32.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-33.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-34.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-35.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-36.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-37.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-38.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-39.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-40.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-41.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-42.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-43.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-44.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-45.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-46.jpg">
<meta property="og:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-47.jpg">
<meta property="article:published_time" content="1970-01-11T16:00:00.000Z">
<meta property="article:modified_time" content="2024-11-01T10:11:15.100Z">
<meta property="article:author" content="星开祈灵">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="JNI">
<meta property="article:tag" content="JRE">
<meta property="article:tag" content="垃圾回收机制">
<meta property="article:tag" content="引用类型">
<meta property="article:tag" content="类与类加载">
<meta property="article:tag" content="内存管理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kokoachino.github.io/images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-1.jpg">
  
    <link rel="alternate" href="/atom.xml" title="星开祈灵的个人博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">星开祈灵的个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">2024-11-1</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://KokoaChino.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-12 JavaJVM 虚拟机" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/1970/01/12/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/" class="article-date">
  <time class="dt-published" datetime="1970-01-11T16:00:00.000Z" itemprop="datePublished">1970-01-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      JavaJVM 虚拟机
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Java, JVM, JNI, JRE, 垃圾回收机制, 引用类型, 类与类加载, 内存管理</p>
<span id="more"></span>



<h1 id="JVM-启动流程"><a href="#JVM-启动流程" class="headerlink" title="JVM 启动流程"></a>JVM 启动流程</h1><p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-1.jpg"></p>
<p>虚拟机的启动入口位于<code>jdk/src/share/bin/java.c</code>的<code>JLI_Launch</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">JLI_Launch</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv,                 <span class="comment">/* 主函数参数个数, argc */</span></span></span><br><span class="line"><span class="params">               <span class="type">int</span> jargc, <span class="type">const</span> <span class="type">char</span>** jargv,          <span class="comment">/* Java 参数 */</span></span></span><br><span class="line"><span class="params">               <span class="type">int</span> appclassc, <span class="type">const</span> <span class="type">char</span>** appclassv,  <span class="comment">/* 应用类路径 */</span></span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="type">char</span>* fullversion,                <span class="comment">/* 定义的完整版本 */</span></span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="type">char</span>* dotversion,                 <span class="comment">/* 定义的小版本 */</span></span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="type">char</span>* pname,                      <span class="comment">/* 程序名称 */</span></span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="type">char</span>* lname,                      <span class="comment">/* 启动器名称 */</span></span></span><br><span class="line"><span class="params">               jboolean javaargs,                      <span class="comment">/* JAVA_ARGS */</span></span></span><br><span class="line"><span class="params">               jboolean cpwildcard,                    <span class="comment">/* 类路径通配符 */</span></span></span><br><span class="line"><span class="params">               jboolean javaw,                         <span class="comment">/* Windows 专用 javaw */</span></span></span><br><span class="line"><span class="params">               jint ergo_class                         <span class="comment">/* 人机工程政策 */</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="1-进行初始化操作"><a href="#1-进行初始化操作" class="headerlink" title="1. 进行初始化操作"></a>1. 进行初始化操作</h2><p>还有<code>Debug</code>信息打印配置等</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">InitLauncher(javaw);</span><br><span class="line">DumpState();</span><br><span class="line"><span class="keyword">if</span> (JLI_IsTraceLauncher()) &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Command line args:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc ; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d] = %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    AddOption(<span class="string">&quot;-Dsun.java.launcher.diag=true&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-选择-JRE-版本"><a href="#2-选择-JRE-版本" class="headerlink" title="2. 选择 JRE 版本"></a>2. 选择 JRE 版本</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 确保指定版本的 JRE 正在运行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 关于 SelectVersion() 例程，有三点需要注意：</span></span><br><span class="line"><span class="comment"> *  1) 如果正在运行的版本不正确，该例程不会返回（要么是正确的版本已被执行，要么是发生了错误）</span></span><br><span class="line"><span class="comment"> *  2) 在此作用域中的 Argc 和 Argv 不会被该例程修改</span></span><br><span class="line"><span class="comment"> *     后续代码有责任忽略由该例程处理的参数</span></span><br><span class="line"><span class="comment"> *  3) 作为副作用，变量 &quot;main_class&quot; 确保被设置（如果它应该被设置的话）</span></span><br><span class="line"><span class="comment"> *     这并不是结构化编程的典型示例，但为了不重复处理 jar 文件操作数，这是一个小代价</span></span><br><span class="line"><span class="comment"> *     （注意：该副作用已被禁用。请参见下面关于 bugid 5030265 的注释）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SelectVersion(argc, argv, &amp;main_class);</span><br></pre></td></tr></table></figure>

<h2 id="3-创建-JVM-执行环境"><a href="#3-创建-JVM-执行环境" class="headerlink" title="3. 创建 JVM 执行环境"></a>3. 创建 JVM 执行环境</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CreateExecutionEnvironment(&amp;argc, &amp;argv, jrepath, <span class="keyword">sizeof</span>(jrepath),</span><br><span class="line">                           jvmpath, <span class="keyword">sizeof</span>(jvmpath), jvmcfg,  <span class="keyword">sizeof</span>(jvmcfg));</span><br></pre></td></tr></table></figure>

<p>此函数只在头文件中定义，具体的实现是根据不同平台而定的</p>
<h2 id="4-加载-JVM"><a href="#4-加载-JVM" class="headerlink" title="4. 加载 JVM"></a>4. 加载 JVM</h2><p>动态加载<code>jvm.so</code>共享库，并把<code>jvm.so</code>中的相关函数导出并且初始化</p>
<p>启动<code>JVM</code>的函数也在其中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!LoadJavaVM(jvmpath, &amp;ifn)) &#123;</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">jboolean <span class="title function_">LoadJavaVM</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *jvmpath, InvocationFunctions *ifn)</span> &#123; <span class="comment">// Mac 实现</span></span><br><span class="line">    Dl_info dlinfo;</span><br><span class="line">    <span class="type">void</span> *libjvm;</span><br><span class="line"></span><br><span class="line">    JLI_TraceLauncher(<span class="string">&quot;JVM path is %s\n&quot;</span>, jvmpath);</span><br><span class="line"></span><br><span class="line">    libjvm = dlopen(jvmpath, RTLD_NOW + RTLD_GLOBAL);</span><br><span class="line">    <span class="keyword">if</span> (libjvm == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        JLI_ReportErrorMessage(DLL_ERROR1, __LINE__);</span><br><span class="line">        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ifn-&gt;CreateJavaVM = (CreateJavaVM_t)</span><br><span class="line">        dlsym(libjvm, <span class="string">&quot;JNI_CreateJavaVM&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ifn-&gt;CreateJavaVM == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ifn-&gt;GetDefaultJavaVMInitArgs = (GetDefaultJavaVMInitArgs_t)</span><br><span class="line">        dlsym(libjvm, <span class="string">&quot;JNI_GetDefaultJavaVMInitArgs&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ifn-&gt;GetDefaultJavaVMInitArgs == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ifn-&gt;GetCreatedJavaVMs = (GetCreatedJavaVMs_t)</span><br><span class="line">    dlsym(libjvm, <span class="string">&quot;JNI_GetCreatedJavaVMs&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ifn-&gt;GetCreatedJavaVMs == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-初始化-JVM"><a href="#5-初始化-JVM" class="headerlink" title="5. 初始化 JVM"></a>5. 初始化 JVM</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> JVMInit(&amp;ifn, threadStackSize, argc, argv, mode, what, ret);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">JVMInit</span><span class="params">(InvocationFunctions* ifn, jlong threadStackSize,</span></span><br><span class="line"><span class="params">                 <span class="type">int</span> argc, <span class="type">char</span> **argv,</span></span><br><span class="line"><span class="params">                 <span class="type">int</span> mode, <span class="type">char</span> *what, <span class="type">int</span> ret)</span> &#123; <span class="comment">// Mac 实现</span></span><br><span class="line">    <span class="keyword">if</span> (sameThread) &#123;</span><br><span class="line">        <span class="comment">// 无需关心...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// 正常情况下走这个</span></span><br><span class="line">        <span class="keyword">return</span> ContinueInNewThread(ifn, threadStackSize, argc, argv, mode, what, ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ContinueInNewThread</span><span class="params">(InvocationFunctions* ifn, jlong threadStackSize,</span></span><br><span class="line"><span class="params">                    <span class="type">int</span> argc, <span class="type">char</span> **argv,</span></span><br><span class="line"><span class="params">                    <span class="type">int</span> mode, <span class="type">char</span> *what, <span class="type">int</span> ret)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        rslt = ContinueInNewThread0(JavaMain, threadStackSize, (<span class="type">void</span>*)&amp;args);</span><br><span class="line">        <span class="comment">/* 如果调用者认为发生了错误</span></span><br><span class="line"><span class="comment">         * 我们直接返回该错误，否则返回被调用者的返回值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> (ret != <span class="number">0</span>) ? ret : rslt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ContinueInNewThread0</span><span class="params">(<span class="type">int</span> (JNICALL *continuation)(<span class="type">void</span> *), jlong stack_size, <span class="type">void</span> * args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rslt;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stack_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        pthread_attr_setstacksize(&amp;attr, stack_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;tid, &amp;attr, (<span class="type">void</span> *(*)(<span class="type">void</span>*))continuation, (<span class="type">void</span>*)args) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">void</span> * tmp;</span><br><span class="line">        pthread_join(tid, &amp;tmp);</span><br><span class="line">        rslt = (<span class="type">int</span>)tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 如果由于某种原因（例如内存不足/LWP）无法创建新线程，</span></span><br><span class="line"><span class="comment">       * 则继续在当前线程中执行。这可能会在后续的 continuation 中失败，</span></span><br><span class="line"><span class="comment">       * 因为 JNI_CreateJavaVM 仍然需要创建许多新线程，但可以先尝试一下</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      rslt = continuation(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">    <span class="keyword">return</span> rslt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-初始化虚拟机"><a href="#6-初始化虚拟机" class="headerlink" title="6. 初始化虚拟机"></a>6. 初始化虚拟机</h2><p>如果报错会直接退出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化虚拟机 */</span></span><br><span class="line">start = CounterGet();</span><br><span class="line"><span class="keyword">if</span> (!InitializeJVM(&amp;vm, &amp;env, &amp;ifn)) &#123;</span><br><span class="line">    JLI_ReportErrorMessage(JVM_ERROR1);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-加载主类"><a href="#7-加载主类" class="headerlink" title="7. 加载主类"></a>7. 加载主类</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取应用程序的主类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参见 bugid 5030265。Main-Class 名称已经从清单中解析出来，</span></span><br><span class="line"><span class="comment"> * 但并没有正确支持 UTF-8。因此，这里的代码忽略之前提取的值，</span></span><br><span class="line"><span class="comment"> * 而是使用现有代码重新提取该值。这可能是发布周期结束时的权宜之计</span></span><br><span class="line"><span class="comment"> * 然而，已经发现通过环境传递某些字符集在某些 Windows 变种上</span></span><br><span class="line"><span class="comment"> * 会有“奇怪”的行为。因此，启动器本地的清单解析代码可能永远不应该增强</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 因此，未来的工作应该是：</span></span><br><span class="line"><span class="comment"> *     1)   修正本地解析代码，确保 Main-Class 属性</span></span><br><span class="line"><span class="comment"> *          能够在所有环境中正确传递，</span></span><br><span class="line"><span class="comment"> *     2)   删除通过环境维护 main_class 的遗留物（并移除这些注释）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该方法还正确处理启动现有的 JavaFX 应用程序，这些应用程序可能</span></span><br><span class="line"><span class="comment"> * 有或没有 Main-Class 清单条目</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mainClass = LoadMainClass(env, mode, what);</span><br></pre></td></tr></table></figure>

<p>对于某些没有主方法的<code>Java</code>程序</p>
<p>比如<code>JavaFX</code>应用，会获取<code>ApplicationMainClass</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在某些情况下，当启动需要助手的应用程序时，例如，</span></span><br><span class="line"><span class="comment"> * 没有主方法的 JavaFX 应用程序，mainClass 不会是应用程序</span></span><br><span class="line"><span class="comment"> * 自身的主类，而是一个助手类。为了保持 UI 中的一致性，</span></span><br><span class="line"><span class="comment"> * 我们需要跟踪并报告应用程序的主类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">appClass = GetApplicationClass(env);</span><br></pre></td></tr></table></figure>

<h2 id="8-初始化完成"><a href="#8-初始化完成" class="headerlink" title="8. 初始化完成"></a>8. 初始化完成</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PostJVMInit 使用类名作为 GUI 目的的应用程序名称，</span></span><br><span class="line"><span class="comment"> * 例如，在 OSX 上，这将设置菜单栏中的应用程序名称，</span></span><br><span class="line"><span class="comment"> * 适用于 SWT 和 JavaFX。因此，我们将在这里传递实际的应用程序类，</span></span><br><span class="line"><span class="comment"> * 而不是 mainClass，因为 mainClass 可能是启动器或助手类，</span></span><br><span class="line"><span class="comment"> * 而不是应用程序类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PostJVMInit(env, appClass, vm);</span><br></pre></td></tr></table></figure>

<h2 id="9-获取主方法"><a href="#9-获取主方法" class="headerlink" title="9. 获取主方法"></a>9. 获取主方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * LoadMainClass 不仅加载主类，还将确保主方法的签名正确，</span></span><br><span class="line"><span class="comment"> * 因此不需要进一步检查。这里调用主方法是为了避免</span></span><br><span class="line"><span class="comment"> * 多余的 Java 栈出现在应用程序的栈跟踪中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mainID = (*env)-&gt;GetStaticMethodID(env, mainClass, <span class="string">&quot;main&quot;</span>, <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="10-调用主方法"><a href="#10-调用主方法" class="headerlink" title="10. 调用主方法"></a>10. 调用主方法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 调用主方法 */</span></span><br><span class="line">(*env)-&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs);</span><br></pre></td></tr></table></figure>

<h2 id="11-主方法结束，销毁-JVM"><a href="#11-主方法结束，销毁-JVM" class="headerlink" title="11. 主方法结束，销毁 JVM"></a>11. 主方法结束，销毁 JVM</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 启动器的退出代码（在没有调用</span></span><br><span class="line"><span class="comment"> * System.exit 的情况下）如果 main 抛出异常将为非零</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret = (*env)-&gt;ExceptionOccurred(env) == <span class="literal">NULL</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">LEAVE(); <span class="comment">// 销毁 JVM</span></span><br></pre></td></tr></table></figure>

<p>至此，一个<code>Java</code>程序的运行流程结束</p>
<h1 id="JNI-调用本地方法"><a href="#JNI-调用本地方法" class="headerlink" title="JNI 调用本地方法"></a>JNI 调用本地方法</h1><h2 id="1-创建本地方法"><a href="#1-创建本地方法" class="headerlink" title="1. 创建本地方法"></a>1. 创建本地方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(sum(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>; <span class="comment">// 本地方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-生成-C-头文件"><a href="#2-生成-C-头文件" class="headerlink" title="2. 生成 C 头文件"></a>2. 生成 C 头文件</h2><p>点击构建按钮，会出现一个<code>out</code>文件夹，也就是生成的<code>class</code>文件在其中</p>
<p>生成对应的<code>C</code>头文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javah -classpath out/production/SimpleHelloWorld -d ./jni com.test.Main</span><br></pre></td></tr></table></figure>

<p>生成的头文件位于<code>jni</code>文件夹下</p>
<h2 id="3-新建-C-项目"><a href="#3-新建-C-项目" class="headerlink" title="3. 新建 C++ 项目"></a>3. 新建 C++ 项目</h2><p>新建一个<code>C++</code>项目，并引入刚刚生成的头文件和导入<code>jni</code>相关头文件（在<code>JDK</code>文件夹中）</p>
<h2 id="4-修改-CMake-文件"><a href="#4-修改-CMake-文件" class="headerlink" title="4. 修改 CMake 文件"></a>4. 修改 CMake 文件</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.21</span>)</span><br><span class="line"><span class="keyword">project</span>(JNITest)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(/Library/Java/JavaVirtualMachines/zulu-<span class="number">8</span>.jdk/Contents/Home/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(/Library/Java/JavaVirtualMachines/zulu-<span class="number">8</span>.jdk/Contents/Home/<span class="keyword">include</span>/darwin)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(JNITest com_test_Main.cpp com_test_Main.h)</span><br></pre></td></tr></table></figure>

<h2 id="5-编写本地方法实现"><a href="#5-编写本地方法实现" class="headerlink" title="5. 编写本地方法实现"></a>5. 编写本地方法实现</h2><p>引用类型对照表</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-2.jpg"></p>
<p>编写实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;com_test_Main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jint JNICALL <span class="title">Java_com_test_Main_sum</span></span></span><br><span class="line"><span class="function">        <span class="params">(JNIEnv * env, jclass clazz, jint a, jint b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b; <span class="comment">// 编写 C++ 实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-编译为动态链接库"><a href="#6-编译为动态链接库" class="headerlink" title="6. 编译为动态链接库"></a>6. 编译为动态链接库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc com_test_Main.cpp -I /Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home/include -I /Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home/include/darwin -fPIC -shared -o test.dll -lstdc++</span><br></pre></td></tr></table></figure>

<p>在 MacOS 下会生成<code>.dylib</code>文件，Windows 下会生成<code>.dll</code>文件（这里就只以 Windows 为例）</p>
<p>编译完成后，得到<code>test.dll</code>文件</p>
<h2 id="7-加载动态链接库文件"><a href="#7-加载动态链接库文件" class="headerlink" title="7. 加载动态链接库文件"></a>7. 加载动态链接库文件</h2><p>最后就可以调用本地方法了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.load(<span class="string">&quot;.dll 文件路径&quot;</span>); <span class="comment">// 加载 .dll 文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(sum(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>; <span class="comment">// 本地方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JVM-内存管理"><a href="#JVM-内存管理" class="headerlink" title="JVM 内存管理"></a>JVM 内存管理</h1><h2 id="内存区域划分"><a href="#内存区域划分" class="headerlink" title="内存区域划分"></a>内存区域划分</h2><p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-3.jpg"></p>
<table>
<thead>
<tr>
<th align="center">内存区域</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">方法区</td>
<td align="center">类信息、即时编译器的代码缓存、运行时常量池</td>
</tr>
<tr>
<td align="center">堆</td>
<td align="center">保存所有的对象和数组</td>
</tr>
<tr>
<td align="center">程序计数器（线程独有）</td>
<td align="center">保存当前程序的执行位置</td>
</tr>
<tr>
<td align="center">虚拟机栈（线程独有）</td>
<td align="center">通过栈帧来维持方法调用顺序，帮助控制程序有序运行</td>
</tr>
<tr>
<td align="center">本地方法栈（线程独有）</td>
<td align="center">同上，作用于本地方法</td>
</tr>
</tbody></table>
<h2 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h2><p>在 JDK8 之前，<code>Hotspot</code>虚拟机的方法区实际上是采用永久代实现的</p>
<p>在 JDK8 之后，<code>Hotspot</code>虚拟机不再使用永久代，而是采用了全新的<strong>元空间</strong></p>
<p>类的元信息被存储在元空间中。元空间没有使用堆内存，而是与堆不相连的本地内存区域</p>
<p>所以，理论上系统可以使用的内存有多大，元空间就有多大，所以不会出现永久代存在时的内存溢出问题</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-4.jpg"></p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-48.jpg"></p>
<h2 id="申请堆外内存"><a href="#申请堆外内存" class="headerlink" title="申请堆外内存"></a>申请堆外内存</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">    unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) unsafeField.get(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">address</span> <span class="operator">=</span> unsafe.allocateMemory(<span class="number">4</span>); <span class="comment">// 申请 4 字节大小的内存空间，并得到对应位置的地址</span></span><br><span class="line">unsafe.putInt(address, <span class="number">6666666</span>); <span class="comment">// 在对应的地址上设定 int 的值</span></span><br><span class="line">System.out.println(unsafe.getInt(address)); <span class="comment">// 获取</span></span><br><span class="line">unsafe.freeMemory(address); <span class="comment">// 释放</span></span><br><span class="line"></span><br><span class="line">System.out.println(unsafe.getInt(address)); <span class="comment">// 再次获取已经获取不到了</span></span><br></pre></td></tr></table></figure>

<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><h2 id="对象存活判定算法"><a href="#对象存活判定算法" class="headerlink" title="对象存活判定算法"></a>对象存活判定算法</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><blockquote>
<p>跟踪对象的引用数量，以确定对象是否可以被回收</p>
</blockquote>
<p><strong>基本概念</strong></p>
<ol>
<li><p><strong>引用计数</strong>：</p>
<p>每个对象都维护一个计数器，表示有多少个引用指向该对象</p>
<p>当一个对象被创建时，它的引用计数初始化为 1</p>
<p>当有新的引用指向该对象时，计数器 +1；当引用不再指向该对象时，计数器 -1</p>
</li>
<li><p><strong>存活判定</strong>：</p>
<p>如果一个对象的引用计数为 0，说明没有任何引用指向它，这时该对象就可以被回收</p>
</li>
</ol>
<p><strong>优缺点</strong></p>
<ol>
<li><p><strong>优点</strong>：</p>
<p>简单直观，易于实现</p>
<p>回收时可以立即释放内存，因为只要引用计数为 0，就可以立即进行回收</p>
</li>
<li><p><strong>缺点</strong>：</p>
<p>循环引用问题：如果两个对象互相引用，即使它们不再被外部引用，它们的引用计数仍然不为 0，导致无法被回收</p>
<p>需要频繁地更新计数器，性能开销相对较高</p>
</li>
</ol>
<p><strong>循环引用示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    Node next;</span><br><span class="line">    Node(Node next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Node</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="type">Node</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(node1);</span><br><span class="line">node1.next = node2; <span class="comment">// node1 和 node2 互相引用</span></span><br></pre></td></tr></table></figure>

<p>在使用引用计数法时，它们的引用计数都不会降到 0，因此它们不会被垃圾回收</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><blockquote>
<p>通过检查对象之间的引用关系，来确定哪些对象是<strong>可达的</strong></p>
<p>即哪些对象仍在使用中，哪些对象可以被回收</p>
</blockquote>
<p><strong>基本思想</strong></p>
<p>从一组称为<strong>根</strong>的对象（根集）开始，递归地检查所有可以访问到的对象</p>
<p>根对象通常包括以下几类：</p>
<ol>
<li><strong>栈上的引用</strong>：活动线程的栈中引用的对象</li>
<li><strong>静态字段</strong>：类的静态字段所引用的对象</li>
<li><strong>本地变量</strong>：方法中的局部变量所引用的对象</li>
<li><strong>常量</strong>：常量池中的对象（例如字符串常量）</li>
<li><strong>JNI 引用</strong>：通过 <strong>JNI</strong> 获得的引用</li>
</ol>
<p><strong>具体实现</strong></p>
<ol>
<li><strong>遍历阶段</strong>：通常使用深度优先搜索或广度优先搜索遍历对象图，标记可达对象</li>
<li><strong>标记阶段</strong>：对于每个可达对象，设置一个标志位，表示该对象是可达的</li>
<li><strong>清理阶段</strong>：遍历堆中所有对象，查找未被标记的对象并将其回收</li>
</ol>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-5.jpg"></p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-6.jpg"></p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-7.jpg"></p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-8.jpg"></p>
<p><strong>优缺点</strong></p>
<ol>
<li><strong>优点</strong>：简单易懂，准确性高，动态性，无需预定义内存区域</li>
<li><strong>缺点</strong>：性能开销，不可预测的暂停时间，内存占用问题，复杂的实现</li>
</ol>
<h3 id="最终判定算法"><a href="#最终判定算法" class="headerlink" title="最终判定算法"></a>最终判定算法</h3><blockquote>
<p>每个对象都有一个<code>finalize</code>方法，当该对象即将被垃圾收集器回收时，这个方法会被调用</p>
<p>在<code>finalize</code>方法执行完成后，如果该对象在<code>finalize</code>方法中仍然被其他对象引用，它就不会被回收</p>
<p>否则，它将被标记为可回收</p>
</blockquote>
<p>虽然在经历了可达性分析算法之后基本可能判定哪些对象能够被回收，但是并不代表此对象一定会被回收</p>
<p>依然可以在最终判定阶段对其进行挽留</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当垃圾收集器确定对象没有更多引用时，将调用该对象的此方法</span></span><br><span class="line"><span class="comment"> * 子类重写 &#123;<span class="doctag">@code</span> finalize&#125; 方法以释放系统资源或执行其他清理操作</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>此方法正是最终判定方法</p>
<p>如果子类重写了此方法，那么子类对象在被判定为可回收时，会进行二次确认，也就是执行<code>finalize()</code>方法</p>
<p>而在此方法中，当前对象是完全有可能重新建立<code>GC Roots</code>的！</p>
<p>所以，如果在二次确认后对象不满足可回收的条件，那么此对象不会被回收</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-9.jpg"></p>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        a  = <span class="literal">null</span>; <span class="comment">// 取消引用</span></span><br><span class="line">        System.gc(); <span class="comment">// 手动申请执行垃圾回收操作</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 等垃圾回收一下</span></span><br><span class="line">        System.out.println(a); <span class="comment">// 还可以获取到</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; <span class="comment">// 重写 finalize 方法</span></span><br><span class="line">            a = <span class="built_in">this</span>; <span class="comment">// 重新建立引用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同一个对象的<code>finalize()</code>方法只会有一次调用机会</p>
<p>也就是说，如果连续两次这样操作，那么第二次，对象必定被回收</p>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        a  = <span class="literal">null</span>; <span class="comment">// 取消引用</span></span><br><span class="line">        System.gc(); <span class="comment">// 手动申请执行垃圾回收操作</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 等垃圾回收一下</span></span><br><span class="line">        System.out.println(a); <span class="comment">// 还可以获取到</span></span><br><span class="line">        </span><br><span class="line">        a  = <span class="literal">null</span>; <span class="comment">// 再次取消引用</span></span><br><span class="line">        System.gc(); <span class="comment">// 手动申请执行垃圾回收操作</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 等垃圾回收一下</span></span><br><span class="line">        System.out.println(a); <span class="comment">// 不能再获取到</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; <span class="comment">// 重写 finalize 方法</span></span><br><span class="line">            a = <span class="built_in">this</span>; <span class="comment">// 重新建立引用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="分代收集机制"><a href="#分代收集机制" class="headerlink" title="分代收集机制"></a>分代收集机制</h3><p><code>Java</code>虚拟机将堆内存划分为<strong>新生代</strong>、<strong>老年代</strong>和<strong>永久代</strong></p>
<blockquote>
<p>在<code>JDK8</code>之前，方法区采用永久代作为实现</p>
<p>而在<code>JDK8</code>之后，方法区采用元空间作为实现，并且使用的是本地内存，容量大小取决于物理机实际大小</p>
</blockquote>
<p>在<code>HotSpot</code>虚拟机中，<strong>新生代</strong>被划分为三块，一块较大的<code>Eden</code>空间和两块较小的<code>Survivor</code>空间，默认比例为<code>8 : 1 : 1</code></p>
<p><strong>老年代</strong>的<code>GC</code>频率相对较低</p>
<p><strong>永久代</strong>一般存放类信息等</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-10.jpg"></p>
<p><strong>具体实现</strong></p>
<ol>
<li><p>所有新创建的对象，在一开始都会进入到新生代的<code>Eden</code>区（如果是大对象会被直接丢进老年代）</p>
<p>初始会对所有新生代区域的对象进行一次扫描，并回收那些不再使用对象</p>
</li>
</ol>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-11.jpg"></p>
<ol start="2">
<li><p>一开始<code>From</code>和<code>To</code>都是空的</p>
<p>而<code>GC</code>之后，所有<code>Eden</code>区域存活的对象都会直接被放入到<code>From</code>区</p>
<p>最后<code>From</code>和<code>To</code>会发生一次交换</p>
</li>
</ol>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-12.jpg"></p>
<ol start="3">
<li><p>对于下一次垃圾回收，操作与上面是一样的</p>
<p>不过这时由于<code>From</code>区域中已经存在对象了</p>
<p>所以，在<code>Eden</code>区的存活对象复制到<code>From</code>区之后，所有<code>To</code>区域中的对象会进行<strong>年龄判定</strong></p>
<blockquote>
<p>每经历一轮<code>GC</code>年龄 +1</p>
<p>如果对象的年龄 &gt; 15（默认值），那么会直接进入到老年代</p>
<p>否则移动到<code>From</code>区</p>
</blockquote>
<p>最后<code>From</code>和<code>To</code>会发生一次交换</p>
</li>
</ol>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-13.jpg"></p>
<ol start="4">
<li>不断重复步骤 3</li>
</ol>
<p><strong>垃圾收集</strong></p>
<ul>
<li><strong>Minor GC</strong>：次要垃圾回收，主要进行新生代区域的垃圾收集<ul>
<li>触发条件：新生代的<code>Eden</code>区容量已满时</li>
</ul>
</li>
<li><strong>Major GC</strong>：主要垃圾回收，主要进行老年代的垃圾收集</li>
<li><strong>Full GC</strong>：完全垃圾回收，对整个<code>Java</code>堆内存和方法区进行垃圾回收<ul>
<li>触发条件 1：每次晋升到老年代的对象平均大小大于老年代剩余空间</li>
<li>触发条件 2：<code>Minor GC</code>后存活的对象超过了老年代剩余空间</li>
<li>触发条件 3：永久代内存不足（<code>JDK8</code>之前）</li>
<li>触发条件 4：手动调用<code>System.gc()</code>方法</li>
</ul>
</li>
</ul>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>当新生代无法容纳更多的的对象时，可以把新生代中的对象移动到老年代中，这样新生代就腾出了空间来容纳更多的对象</p>
<p>首先会判断一下之前的每次垃圾回收进入老年代的平均大小是否小于当前老年代的剩余空间</p>
<p>如果小于，那么说明也许可以放得下</p>
<p>否则，会先来一次<code>Full GC</code>，进行一次大规模垃圾回收，来尝试腾出空间</p>
<p>再次判断老年代是否有空间存放，要是还是装不下，直接抛出<code>OutOfMemoryError</code>错误</p>
<p><strong>Minor GC 的整个过程</strong></p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-14.jpg"></p>
<h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>标记出所有需要回收的对象，然后再依次回收掉被标记的对象</p>
<p>（或是标记出所有不需要回收的对象，只回收未标记的对象）</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-15.jpg"></p>
<p><strong>缺点</strong></p>
<p>连续的内存空间可能会出现许许多多的空隙，碎片化会导致连续内存空间利用率降低</p>
<h3 id="标记复制算法"><a href="#标记复制算法" class="headerlink" title="标记复制算法"></a>标记复制算法</h3><p>将内存区域划分为大小相同的两块区域，每次只使用其中的一块区域</p>
<p>每次垃圾回收结束后，将所有存活的对象全部复制到另一块区域中，并一次性清空当前区域</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-16.jpg"></p>
<p>虽然浪费了一些时间进行复制操作，但是这样能够很好地解决对象大面积回收后空间碎片化严重的问题</p>
<p>这种算法就非常适用于新生代（因为新生代的回收效率极高，一般不会留下太多的对象）的垃圾回收</p>
<h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>在标记所有待回收对象之后，不急着去进行回收操作</p>
<p>而是将所有待回收的对象整齐排列在一段内存空间中，而需要回收的对象全部往后丢</p>
<p>这样，前半部分的所有对象都是无需进行回收的，而后半部分直接一次性清除即可</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-17.jpg"></p>
<p><strong>缺点</strong></p>
<p>它的效率比前两者都低</p>
<p>甚至，由于需要修改对象在内存中的位置，此时程序必须要暂停才可以</p>
<p>而且，在极端情况下，可能会导致整个程序发生停顿</p>
<p>所以，可以将标记清除算法和标记整理算法混合使用</p>
<p>在内存空间还不是很凌乱的时候，采用标记清除算法；当内存空间凌乱到一定程度后，进行一次标记整理算法</p>
<p>这种算法就非常适用于老年代（因为老年代的回收效率较低，对象的生命周期较长）的垃圾回收</p>
<h2 id="垃圾收集器实现"><a href="#垃圾收集器实现" class="headerlink" title="垃圾收集器实现"></a>垃圾收集器实现</h2><h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>这是一款单线程的垃圾收集器</p>
<p>也就是说，当开始进行垃圾回收时，需要暂停所有的线程，直到垃圾收集工作结束</p>
<p>它的新生代收集算法采用的是标记复制算法，老年代采用的是标记整理算法</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-18.jpg"></p>
<h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>相当于是 Serial 收集器的多线程版本，它能够支持多线程垃圾收集</p>
<p>除了多线程支持以外，其他内容基本与 Serial 收集器一致</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-19.jpg"></p>
<h3 id="Parallel-Scavenge-Parallel-Old-收集器"><a href="#Parallel-Scavenge-Parallel-Old-收集器" class="headerlink" title="Parallel Scavenge &#x2F; Parallel Old 收集器"></a>Parallel Scavenge &#x2F; Parallel Old 收集器</h3><p>Parallel Scavenge 是一款面向新生代的垃圾收集器，采用标记复制算法实现</p>
<p>Parallel Old 是一款面向老年代的垃圾收集器，采用标记整理算法实现</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-20.jpg"></p>
<p>与 ParNew 收集器不同的是，它会自动衡量一个吞吐量，并根据吞吐量来决定每次垃圾回收的时间</p>
<p>这种自适应机制，能够很好地权衡当前机器的性能，根据性能选择最优方案</p>
<p>目前 JDK8 采用的就是这种 Parallel Scavenge + Parallel Old 的垃圾回收方案</p>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>它主要采用标记清除算法，第一次实现了让垃圾收集线程与用户线程同时工作</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-21.jpg"></p>
<p>它的垃圾回收分为 4 个阶段：</p>
<ul>
<li><p><strong>初始标记</strong>：标记出<code>GC Roots</code>能够直接关联到的对象，速度比较快</p>
</li>
<li><p><strong>并发标记</strong>：从<code>GC Roots</code>的直接关联对象开始遍历整个对象图的过程</p>
<p>​                   这个过程耗时较长，但是不需要停顿用户线程</p>
</li>
<li><p><strong>重新标记</strong>：再次暂停所有线程进行并行标记，耗时会比初始标记的时间长一点</p>
</li>
<li><p><strong>并发清除</strong>：最后直接将所有标记好的无用对象进行删除，与用户线程并发运行</p>
</li>
</ul>
<h3 id="Garbage-First-G1-收集器"><a href="#Garbage-First-G1-收集器" class="headerlink" title="Garbage First (G1) 收集器"></a>Garbage First (G1) 收集器</h3><p>在 JDK9 时，取代了 JDK8 默认的 Parallel Scavenge + Parallel Old 的回收方案</p>
<p>它将整个 Java 堆划分成<code>2048</code>个大小相同的独立<code>Region</code>块，每个<code>Region</code>块的大小根据堆空间的实际大小而定</p>
<p>整体被控制在<code>1MB</code>到<code>32MB</code>之间，且都为<code>2</code>的<code>N</code>次幂</p>
<p>所有的<code>Region</code>块大小相同，且在 JVM 的整个生命周期内不会发生改变</p>
<p>每一个<code>Region</code>块都可以根据需要，自由决定扮演哪个角色（<code>Eden</code>、<code>Survivor</code>和老年代）</p>
<p>收集器会根据对应的角色采用不同的回收策略</p>
<p>此外，G1 收集器还存在一个<code>Humongous</code>区域，它专门用于存放大对象（一般认为大小超过了<code>Region</code>容量的一半的对象为大对象）</p>
<p>这样，新生代、老年代在物理上，不再是一个连续的内存区域，而是到处分布的</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-22.jpg"></p>
<p>它的回收过程与 CMS 大体类似：</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-23.jpg"></p>
<p>它的垃圾回收分为 4 个阶段：</p>
<ul>
<li><p><strong>初始标记</strong>：标记出<code>GC Roots</code>能够直接关联到的对象，并且修改<code>TAMS</code>指针的值</p>
<p>​                   让下一阶段用户线程并发运行时，能正确地在可用的<code>Region</code>中分配新对象</p>
<p>​                   这个阶段耗时很短，而且是借用进行<code>Minor GC</code>的时候同步完成的，所以 G1 收集器在这个阶段实际并没有额外的停顿</p>
</li>
<li><p><strong>并发标记</strong>：从<code>GC Roots</code>的直接关联对象开始遍历整个对象图的过程</p>
<p>​                   这个过程耗时较长，但是不需要停顿用户线程</p>
</li>
<li><p><strong>最终标记</strong>：对用户线程做一个短暂的暂停，用于处理并发标记阶段漏标的那一部分对象</p>
</li>
<li><p><strong>筛选回收</strong>：负责更新<code>Region</code>的统计数据，对各个<code>Region</code>的回收价值和成本进行排序</p>
<p>​				   根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个<code>Region</code>构成回收集</p>
<p>​		     	  然后把决定回收的那一部分<code>Region</code>的存活对象复制到空的<code>Region</code>中，再清理掉整个旧的<code>Region</code>的全部空间</p>
<p>​				   这里的操作涉及存活对象的移动，是必须暂停用户线程，由多个收集器线程并行完成的</p>
</li>
</ul>
<h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<p>只要强引用存在，JVM 就不会回收被引用的对象</p>
<p>即使系统内存不足，强引用对象也不会被回收</p>
<h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;Object&gt; softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br></pre></td></tr></table></figure>

<p>JVM 会在内存不足时回收软引用指向的对象</p>
<p>但如果内存充足，软引用对象会一直存在</p>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;Object&gt; weakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br></pre></td></tr></table></figure>

<p>当 JVM 进行垃圾回收时，如果发现一个对象只被弱引用指向</p>
<p>则无论内存是否充足，该对象都会被回收</p>
<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhantomReference&lt;Object&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;());</span><br></pre></td></tr></table></figure>

<p>虚引用的存在不会影响对象的生命周期，只有在对象被回收后，虚引用才会被加入到一个引用队列中</p>
<h1 id="类与类加载"><a href="#类与类加载" class="headerlink" title="类与类加载"></a>类与类加载</h1><h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h2><h3 id="类文件信息"><a href="#类文件信息" class="headerlink" title="类文件信息"></a>类文件信息</h3><p>可以使用<code>WinHex</code>软件来以十六进制查看字节码文件</p>
<p>之后的演示以下面的代码为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将在 IDEA 中编译出来的<code>class</code>文件拖动进<code>WinHex</code></p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-24.jpg"></p>
<h4 id="1-模数"><a href="#1-模数" class="headerlink" title="1. 模数"></a>1. 模数</h4><p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-25.jpg"></p>
<p>前<code>4</code>个字节组成了魔数，字节码文件的魔数为：<code>CAFEBABE</code></p>
<p>它在字节码文件中的作用是帮助 JVM 确认文件的格式是否正确</p>
<p>当 JVM 读取一个<code>.class</code>文件时，会首先检查这个标识符，以确保它是一个合法的 Java 类文件</p>
<h4 id="2-版本号"><a href="#2-版本号" class="headerlink" title="2. 版本号"></a>2. 版本号</h4><p>紧接着<code>4</code>个字节存储的是字节码文件的版本号</p>
<p>前<code>2</code>个字节是次要版本号，后<code>2</code>个字节是主要版本号</p>
<p>像上面的主要版本号为<code>34</code>，转为十进制后为<code>52</code>，它代表的是 JDK8 的字节码文件</p>
<table>
<thead>
<tr>
<th align="center">主要版本号</th>
<th align="center">JDK 版本</th>
</tr>
</thead>
<tbody><tr>
<td align="center">49</td>
<td align="center">JDK 5</td>
</tr>
<tr>
<td align="center">50</td>
<td align="center">JDK 6</td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">JDK 7</td>
</tr>
<tr>
<td align="center">52</td>
<td align="center">JDK 8</td>
</tr>
<tr>
<td align="center">53</td>
<td align="center">JDK 9</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">64</td>
<td align="center">JDK 20</td>
</tr>
</tbody></table>
<p>JVM 会根据版本号决定是否能够运行，Java 版本是向下兼容的</p>
<h4 id="3-常量池大小"><a href="#3-常量池大小" class="headerlink" title="3. 常量池大小"></a>3. 常量池大小</h4><p>紧接着<code>2</code>个字节存放了类中常量池大小</p>
<p>（这里的常量并不是指手动创建的<code>final</code>类型常量，而是程序运行一些需要用到的常量数据，比如字面量和符号引用等）</p>
<p>由于常量的数量不是确定的，所以在最开始的位置会存放常量池中常量的数量</p>
<p>（比如这里是<code>18</code>，翻译为十进制就是<code>24</code>，从<code>1</code>开始算，所以实际上有<code>23</code>个常量）</p>
<h4 id="4-常量池数据"><a href="#4-常量池数据" class="headerlink" title="4. 常量池数据"></a>4. 常量池数据</h4><p>每一项常量池里面的数据都是一个表，它们都是以<code>_info</code>结尾的</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-26.jpg"></p>
<h4 id="5-常量池数据表"><a href="#5-常量池数据表" class="headerlink" title="5. 常量池数据表"></a>5. 常量池数据表</h4><p><code>1</code>号常量：</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-27.jpg"></p>
<p>第一行是一个<code>1</code>个字节的无符号数，用于表示当前常量类型</p>
<table>
<thead>
<tr>
<th align="center">常量类型</th>
<th align="center">标志</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>CONSTANT_Utf8_info</code></td>
<td align="center">1</td>
<td align="center"><code>UTF-8</code>编码格式的字符串</td>
</tr>
<tr>
<td align="center"><code>CONSTANT_Integer_info</code></td>
<td align="center">3</td>
<td align="center">整形字面量</td>
</tr>
<tr>
<td align="center"><code>CONSTANT_Class_info</code></td>
<td align="center">7</td>
<td align="center">类或接口的符号引用</td>
</tr>
<tr>
<td align="center"><code>CONSTANT_String_info</code></td>
<td align="center">8</td>
<td align="center">字符串类型的字面量</td>
</tr>
<tr>
<td align="center"><code>CONSTANT_Fieldref_info</code></td>
<td align="center">9</td>
<td align="center">字段的符号引用</td>
</tr>
<tr>
<td align="center"><code>CONSTANT_Methodref_info</code></td>
<td align="center">10</td>
<td align="center">方法的符号引用</td>
</tr>
<tr>
<td align="center"><code>CONSTANT_MethodType_info</code></td>
<td align="center">16</td>
<td align="center">方法类型</td>
</tr>
<tr>
<td align="center"><code>CONSTANT_NameAndType_info</code></td>
<td align="center">12</td>
<td align="center">字段或方法的部分符号引用</td>
</tr>
</tbody></table>
<p>第二三行：</p>
<table>
<thead>
<tr>
<th align="center">项目</th>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向声明方法的类描述父<code>CONSTANT_Class_info</code>索引项</td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">u2</td>
<td align="center">指向名称及类型描述符<code>CONSTANT_NameAndType_info</code>索引项</td>
</tr>
</tbody></table>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-28.jpg"></p>
<p>第一个索引项指向了第<code>3</code>号常量</p>
<p><code>3</code>号常量：</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-29.jpg"></p>
<p><code>23</code>号常量：</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-30.jpg"></p>
<p>指向的<code>UTF-8</code>字符串值为<code>java/lang/Object</code>，说明这个方法是由<code>Object</code>类定义的</p>
<p>第二项<code>name_and_type_index</code>，指向了<code>21</code>号常量，也就是字段或方法的部分符号引用</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-31.jpg"></p>
<p><code>4</code>号和<code>5</code>号常量：</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-32.jpg"></p>
<p>方法名称为<code>&lt;init&gt;</code>，说明这是一个构造方法的名称；普通方法名称是什么就是什么</p>
<p>方法描述符为<code>()V</code>，表示此方法没有任何参数，并且返回值类型为<code>void</code></p>
<p>描述符对照表：</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-33.jpg"></p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">描述符</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>public int test(double a, char c)&#123;&#125;</code></td>
<td align="center"><code>(DC)I</code></td>
</tr>
<tr>
<td align="center"><code>public String test(Object obj)&#123;&#125;</code></td>
<td align="center"><code>(Ljava/lang/Object;)Ljava/lang/String</code></td>
</tr>
<tr>
<td align="center"><code>public void test(int[][] arr)</code></td>
<td align="center"><code>([[I)V</code></td>
</tr>
</tbody></table>
<p>所以，这里表示的实际上就是此方法是一个无参构造方法，并且是属于<code>Object</code>类的</p>
<h4 id="6-访问标志"><a href="#6-访问标志" class="headerlink" title="6. 访问标志"></a>6. 访问标志</h4><p>访问标志就是类的种类以及类上添加的一些关键字等内容</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-34.jpg"></p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-35.jpg"></p>
<p>访问标志值按类的属性按位异或进行运算</p>
<h4 id="7-类索引、父类索引、接口索引"><a href="#7-类索引、父类索引、接口索引" class="headerlink" title="7. 类索引、父类索引、接口索引"></a>7. 类索引、父类索引、接口索引</h4><p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-36.jpg"></p>
<p>它们的值也是指向常量池中的值</p>
<p>其中<code>2</code>号常量正是存储的当前类信息，<code>3</code>号常量存储的是父类信息</p>
<h4 id="8-字段表"><a href="#8-字段表" class="headerlink" title="8. 字段表"></a>8. 字段表</h4><p>之后的演示以下面的代码为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-37.jpg"></p>
<p>一共有四个<code>2</code>字节的数据</p>
<p>第一个数据<code>access_flags</code>是字段的访问标志</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-38.jpg"></p>
<p>第二个数据<code>name_index</code>是字段的名称常量，这里指向的是<code>5</code>号常量</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-39.jpg"></p>
<p>第三个数据<code>descirptor_index</code>是描述符</p>
<p>第四个数据<code>attrbutes_count</code>是属性计数器，用于描述一些额外信息</p>
<h4 id="9-方法表"><a href="#9-方法表" class="headerlink" title="9. 方法表"></a>9. 方法表</h4><p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-40.jpg"></p>
<p>一共有三个方法</p>
<p>其中第一个方法的方法名称为<code>&lt;init&gt;</code>，表示它是一个构造方法</p>
<p>第二个方法看名称，很显然就是<code>main</code>方法</p>
<p>最后一个方法名称为<code>&lt;clinit&gt;</code>，这个是类在初始化时会调用的方法（是隐式的，自动生成的）</p>
<p>它主要是用于静态变量初始化语句和静态块的执行</p>
<h4 id="10-属性表"><a href="#10-属性表" class="headerlink" title="10.  属性表"></a>10.  属性表</h4><p>实际上在类中、字段中、方法中都可以携带自己的属性表</p>
<p>属性表存放的正是代码、本地变量等数据</p>
<p>比如<code>main</code>方法就存在<code>4</code>个本地变量：</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-41.jpg"></p>
<p>属性信息呈现套娃状态</p>
<p>在此方法中的属性包括了一个<code>Code</code>属性，存放代码编译之后的字节码指令，而且又嵌套了本地变量表和源码行号表</p>
<p><code>Code</code>中存放的就是所有的字节码指令：</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-42.jpg"></p>
<h4 id="11-本地变量表"><a href="#11-本地变量表" class="headerlink" title="11. 本地变量表"></a>11. 本地变量表</h4><p>存放了方法中要用到的局部变量：</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-43.jpg"></p>
<p>一共有四个本地变量（<code>args, i, a, b</code>）</p>
<p>并且表中存放了本地变量的长度、名称、描述符等内容</p>
<h4 id="12-类属性"><a href="#12-类属性" class="headerlink" title="12. 类属性"></a>12. 类属性</h4><p>此属性记录的是源文件名称</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-44.jpg"></p>
<h3 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h3><p>虚拟机的指令是由一个字节长度的、代表某种特定操作含义的数字（操作码，类似于机器语言）</p>
<p>操作码后面也可以携带<code>0</code>个或多个参数一起执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译为字节码文件：</p>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-45.jpg"></p>
<ul>
<li><code>bipush</code>：将<code>10</code>送至操作数栈顶</li>
<li><code>istore_1</code>：将操作数栈顶的值存进<code>1</code>号本地变量，也就是变量<code>i</code>中</li>
<li><code>iload_1</code>：将<code>1</code>号本地变量中的值推向操作数栈顶</li>
<li><code>iinc 1 by 1</code>：将<code>1</code>号本地变量的值增加<code>1</code></li>
<li><code>istore_2</code>：将操作数栈顶的值<code>10</code>存入<code>2</code>号本地变量</li>
<li><code>iinc 1 by 1</code>：将<code>1</code>号本地变量的值增加<code>1</code></li>
<li><code>iload_1</code>：将<code>1</code>号本地变量中的值推向操作数栈顶</li>
<li><code>istore_3</code>：将操作数栈顶的值<code>12</code>存入<code>2</code>号本地变量</li>
<li><code>return</code>：结束</li>
</ul>
<p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-46.jpg"></p>
<h3 id="ASM-字节码编程"><a href="#ASM-字节码编程" class="headerlink" title="ASM 字节码编程"></a>ASM 字节码编程</h3><p><strong>演示</strong>：使用 <strong>ASM 字节码编程</strong>创建下面的<code>Main</code>类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Main</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-获取-ClassWriter-对象"><a href="#1-获取-ClassWriter-对象" class="headerlink" title="1. 获取 ClassWriter 对象"></a>1. 获取 ClassWriter 对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><code> </code>：不会自动计算操作数栈和局部临时变量表大小，需要自己手动来指定</li>
<li><code>ClassWriter.COMPUTE_MAXS</code>：会自动计算上述操作数栈和局部临时变量表大小，但需要手动触发</li>
<li><code>ClassWriter.COMPUTE_FRAMES</code>：不仅会计算上述操作数栈和局部临时变量表大小，而且会自动计算<code>StackMapFrames</code></li>
</ul>
<h4 id="2-指定类的一些基本信息"><a href="#2-指定类的一些基本信息" class="headerlink" title="2. 指定类的一些基本信息"></a>2. 指定类的一些基本信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer.visit(V1_8, ACC_PUBLIC, <span class="string">&quot;com/test/Main&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><code>V1_8</code>：字节码文件的版本</li>
<li><code>ACC_PUBLIC</code>：访问权限</li>
<li><code>&quot;com/test/Main&quot;</code>：类名称</li>
<li><code>null</code>：标签</li>
<li><code>&quot;java/lang/Object&quot;</code>：父类</li>
<li><code>null</code>：接口</li>
</ul>
<h4 id="3-添加无参构造方法"><a href="#3-添加无参构造方法" class="headerlink" title="3. 添加无参构造方法"></a>3. 添加无参构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer.visitMethod(ACC_PUBLIC, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>); <span class="comment">// 添加一个新方法</span></span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><code>ACC_PUBLIC</code>：访问权限</li>
<li><code>&quot;&lt;init&gt;&quot;</code>：方法名称</li>
<li><code>&quot;()V&quot;</code>：方法修饰符</li>
<li><code>null</code>：描述符</li>
<li><code>null</code>：异常</li>
</ul>
<h4 id="4-调用父类构造方法"><a href="#4-调用父类构造方法" class="headerlink" title="4. 调用父类构造方法"></a>4. 调用父类构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MethodVisitor</span> <span class="variable">visitor</span> <span class="operator">=</span> writer.visitMethod(ACC_PUBLIC, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>); <span class="comment">// 创建一个公共构造方法</span></span><br><span class="line">visitor.visitCode(); <span class="comment">// 开始生成方法的字节码</span></span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(); <span class="comment">// 创建一个标签用于标记代码位置</span></span><br><span class="line">visitor.visitLabel(l1); <span class="comment">// 将标签 l1 添加到当前代码流</span></span><br><span class="line">visitor.visitLineNumber(<span class="number">11</span>, l1); <span class="comment">// 指定源代码行号与标签 l1 关联</span></span><br><span class="line"></span><br><span class="line">visitor.visitVarInsn(ALOAD, <span class="number">0</span>); <span class="comment">// 将当前对象引用（this）推入操作数栈</span></span><br><span class="line">visitor.visitMethodInsn(INVOKESPECIAL, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">false</span>); <span class="comment">// 调用父类的构造函数 java/lang/Object 的 &lt;init&gt; 方法</span></span><br><span class="line">visitor.visitInsn(RETURN); <span class="comment">// 返回方法，无返回值</span></span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(); <span class="comment">// 创建另一个标签用于结束位置</span></span><br><span class="line">visitor.visitLabel(l2); <span class="comment">// 将标签 l2 添加到当前代码流</span></span><br><span class="line">visitor.visitLocalVariable(<span class="string">&quot;this&quot;</span>, <span class="string">&quot;Lcom/test/Main;&quot;</span>, <span class="literal">null</span>, l1, l2, <span class="number">0</span>); <span class="comment">// 在本地变量表中添加 this 变量</span></span><br><span class="line"></span><br><span class="line">visitor.visitMaxs(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 设置方法的最大栈深度和本地变量数量</span></span><br><span class="line">visitor.visitEnd(); <span class="comment">// 结束方法的字节码生成</span></span><br></pre></td></tr></table></figure>

<h4 id="5-编写-main-方法"><a href="#5-编写-main-方法" class="headerlink" title="5. 编写 main 方法"></a>5. 编写 main 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MethodVisitor</span> <span class="variable">v2</span> <span class="operator">=</span> writer.visitMethod(ACC_PUBLIC | ACC_STATIC, <span class="string">&quot;main&quot;</span>, <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>); <span class="comment">// 创建一个 main 方法</span></span><br><span class="line">v2.visitCode(); <span class="comment">// 开始生成方法的字节码</span></span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">l3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(); <span class="comment">// 记录起始行信息</span></span><br><span class="line">v2.visitLabel(l3); <span class="comment">// 将标签 l3 添加到当前代码流</span></span><br><span class="line">v2.visitLineNumber(<span class="number">13</span>, l3); <span class="comment">// 指定源代码行号与标签 l3 关联</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先是 int a = 10 的操作，执行指令依次为：</span></span><br><span class="line"><span class="comment">// bipush 10     将 10 推向操作数栈顶</span></span><br><span class="line"><span class="comment">// istore_1      将操作数栈顶元素保存到 1 号本地变量 a 中</span></span><br><span class="line">v2.visitIntInsn(BIPUSH, <span class="number">10</span>); <span class="comment">// 将 10 推入操作数栈</span></span><br><span class="line">v2.visitVarInsn(ISTORE, <span class="number">1</span>); <span class="comment">// 将栈顶元素存入本地变量 a</span></span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">l4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">v2.visitLabel(l4); <span class="comment">// 创建并添加标签 l4</span></span><br><span class="line">v2.visitLineNumber(<span class="number">14</span>, l4); <span class="comment">// 指定源代码行号与标签 l4 关联</span></span><br><span class="line"></span><br><span class="line">v2.visitFieldInsn(GETSTATIC, <span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;out&quot;</span>, <span class="string">&quot;Ljava/io/PrintStream;&quot;</span>); <span class="comment">// 获取 System.out</span></span><br><span class="line">v2.visitVarInsn(ILOAD, <span class="number">1</span>); <span class="comment">// 加载本地变量 a 的值</span></span><br><span class="line">v2.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/io/PrintStream&quot;</span>, <span class="string">&quot;println&quot;</span>, <span class="string">&quot;(I)V&quot;</span>, <span class="literal">false</span>); <span class="comment">// 调用 println 方法</span></span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">l6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">v2.visitLabel(l6); <span class="comment">// 创建并添加标签 l6</span></span><br><span class="line">v2.visitLineNumber(<span class="number">15</span>, l6); <span class="comment">// 指定源代码行号与标签 l6 关联</span></span><br><span class="line"></span><br><span class="line">v2.visitInsn(RETURN); <span class="comment">// 返回方法，无返回值</span></span><br><span class="line"><span class="type">Label</span> <span class="variable">l7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">v2.visitLabel(l7); <span class="comment">// 创建并添加标签 l7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后是本地变量表中的各个变量</span></span><br><span class="line">v2.visitLocalVariable(<span class="string">&quot;args&quot;</span>, <span class="string">&quot;[Ljava/lang/String;&quot;</span>, <span class="literal">null</span>, l3, l7, <span class="number">0</span>); <span class="comment">// args 变量</span></span><br><span class="line">v2.visitLocalVariable(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="literal">null</span>, l4, l7, <span class="number">1</span>); <span class="comment">// a 变量</span></span><br><span class="line">v2.visitMaxs(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 设置方法的最大栈深度和本地变量数量</span></span><br><span class="line">v2.visitEnd(); <span class="comment">// 结束方法的字节码生成</span></span><br></pre></td></tr></table></figure>

<h4 id="6-保存字节码文件"><a href="#6-保存字节码文件" class="headerlink" title="6. 保存字节码文件"></a>6. 保存字节码文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);</span><br><span class="line">        writer.visit(V1_8, ACC_PUBLIC,<span class="string">&quot;com/test/Main&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        writer.visitMethod(ACC_PUBLIC, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">MethodVisitor</span> <span class="variable">visitor</span> <span class="operator">=</span> writer.visitMethod(ACC_PUBLIC, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>); <span class="comment">// 无参构造</span></span><br><span class="line">        visitor.visitCode();</span><br><span class="line">        <span class="type">Label</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">        visitor.visitLabel(l1);</span><br><span class="line">        visitor.visitLineNumber(<span class="number">11</span>, l1);</span><br><span class="line">        visitor.visitVarInsn(ALOAD, <span class="number">0</span>); <span class="comment">// 将当前对象引用（this）推入操作数栈</span></span><br><span class="line">        visitor.visitMethodInsn(INVOKESPECIAL, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">false</span>); <span class="comment">// 调用父类构造函数</span></span><br><span class="line">        visitor.visitInsn(RETURN);</span><br><span class="line">        <span class="type">Label</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">        visitor.visitLabel(l2);</span><br><span class="line">        visitor.visitLocalVariable(<span class="string">&quot;this&quot;</span>, <span class="string">&quot;Lcom/test/Main;&quot;</span>, <span class="literal">null</span>, l1, l2, <span class="number">0</span>); <span class="comment">// 在本地变量表中添加 this 变量</span></span><br><span class="line">        visitor.visitMaxs(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 设置方法的最大栈深度和本地变量数量</span></span><br><span class="line">        visitor.visitEnd();</span><br><span class="line">        </span><br><span class="line">        <span class="type">MethodVisitor</span> <span class="variable">v2</span> <span class="operator">=</span> writer.visitMethod(ACC_PUBLIC | ACC_STATIC, <span class="string">&quot;main&quot;</span>, <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>); <span class="comment">// 创建一个 main 方法</span></span><br><span class="line">        v2.visitCode();</span><br><span class="line">        <span class="type">Label</span> <span class="variable">l3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">        v2.visitLabel(l3);</span><br><span class="line">        v2.visitLineNumber(<span class="number">13</span>, l3);</span><br><span class="line">        v2.visitIntInsn(BIPUSH, <span class="number">10</span>); <span class="comment">// 将 10 推入操作数栈</span></span><br><span class="line">        v2.visitVarInsn(ISTORE, <span class="number">1</span>); <span class="comment">// 将栈顶元素存入本地变量 a</span></span><br><span class="line">        <span class="type">Label</span> <span class="variable">l4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">        v2.visitLabel(l4);</span><br><span class="line">        v2.visitLineNumber(<span class="number">14</span>, l4);</span><br><span class="line">        v2.visitFieldInsn(GETSTATIC, <span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;out&quot;</span>, <span class="string">&quot;Ljava/io/PrintStream;&quot;</span>); <span class="comment">// 获取 System.out</span></span><br><span class="line">        v2.visitVarInsn(ILOAD, <span class="number">1</span>); <span class="comment">// 加载本地变量 a 的值</span></span><br><span class="line">        v2.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/io/PrintStream&quot;</span>, <span class="string">&quot;println&quot;</span>, <span class="string">&quot;(I)V&quot;</span>, <span class="literal">false</span>); <span class="comment">// 调用 println 方法</span></span><br><span class="line">        <span class="type">Label</span> <span class="variable">l6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">        v2.visitLabel(l6);</span><br><span class="line">        v2.visitLineNumber(<span class="number">15</span>, l6);</span><br><span class="line">        v2.visitInsn(RETURN);</span><br><span class="line">        <span class="type">Label</span> <span class="variable">l7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">        v2.visitLabel(l7);</span><br><span class="line">        v2.visitLocalVariable(<span class="string">&quot;args&quot;</span>, <span class="string">&quot;[Ljava/lang/String;&quot;</span>, <span class="literal">null</span>, l3, l7, <span class="number">0</span>); <span class="comment">// args 变量</span></span><br><span class="line">        v2.visitLocalVariable(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="literal">null</span>, l4, l7, <span class="number">1</span>); <span class="comment">// a 变量</span></span><br><span class="line">        v2.visitMaxs(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 设置方法的最大栈深度和本地变量数量</span></span><br><span class="line">        v2.visitEnd();</span><br><span class="line">        </span><br><span class="line">        writer.visitEnd(); <span class="comment">// 结束编辑</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./Main.class&quot;</span>)) &#123;</span><br><span class="line">            stream.write(writer.toByteArray()); <span class="comment">// 将字节码文件转换为 byte 数组，并保存到根目录下</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-IDEA-反编译"><a href="#7-IDEA-反编译" class="headerlink" title="7. IDEA 反编译"></a>7. IDEA 反编译</h4><p>结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Main</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="类加载触发条件"><a href="#类加载触发条件" class="headerlink" title="类加载触发条件"></a>类加载触发条件</h3><p>一般在这些情况下，如果类没有被加载，那么会被自动加载：</p>
<ul>
<li>使用<code>new</code>关键字创建对象</li>
<li>使用类的非<code>final</code>类型的静态字段或静态方法</li>
<li>使用反射对类信息进行获取的时候</li>
<li>加载一个类的子类</li>
<li>加载接口的实现类，且接口带有<code>default</code>的方法默认实现</li>
</ul>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p><img src="/../images/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA-47.jpg"></p>
<h4 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h4><p>JVM 将类的二进制字节流读入内存，并创建一个<code>Class</code>对象来表示这个类</p>
<h4 id="2-校验"><a href="#2-校验" class="headerlink" title="2. 校验"></a>2. 校验</h4><p>校验阶段主要是为了确保加载的类符合 Java 语言规范，保证安全性</p>
<p>校验主要包括以下几个方面：</p>
<ul>
<li><strong>文件格式验证</strong>：检查字节码文件是否符合 <code>.class</code> 文件的格式（魔数，主次版号…）</li>
<li><strong>元数据验证</strong>：检查类的结构是否符合 Java 语言规范，包括字段、方法等的访问修饰符等</li>
<li><strong>字节码验证</strong>：检查字节码指令是否合法，确保没有使用不安全的操作，如非法的类型转换</li>
</ul>
<h4 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h4><p>JVM 会为类中的静态变量分配内存，并将它们初始化为默认值（如<code>0</code>、<code>null</code>等）</p>
<h4 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h4><p>将常量池中的符号引用转换为直接引用（符号引用是一种更高层次的抽象，直接引用则是内存地址）</p>
<p>JVM 会将类、字段和方法的符号引用转换为具体的内存地址</p>
<h4 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h4><p>执行类的静态初始化块和静态变量赋值，这是类生命周期中的最后一个阶段</p>
<p>JVM 会执行<code>&lt;clinit&gt;</code>方法，确保所有静态变量和静态代码块都被正确初始化</p>
<h4 id="6-使用"><a href="#6-使用" class="headerlink" title="6. 使用"></a>6. 使用</h4><p>类的信息已经完全加载到内存中，并且可以直接使用</p>
<h4 id="7-卸载"><a href="#7-卸载" class="headerlink" title="7. 卸载"></a>7. 卸载</h4><p>当类不再被使用时，JVM 可以将其从内存中卸载</p>
<p>类的卸载并不频繁发生，通常在以下情况下进行：</p>
<ul>
<li>类加载器被卸载（如应用程序关闭）</li>
<li>类没有被任何对象引用</li>
</ul>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在 Java 虚拟机中的唯一性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>使用两个不同的类加载器加载<code>Test</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ReflectiveOperationException &#123;</span><br><span class="line">        Class&lt;?&gt; testClass1 = Main.class.getClassLoader().loadClass(<span class="string">&quot;com.test.Test&quot;</span>); <span class="comment">// 使用系统类加载器加载类</span></span><br><span class="line">        <span class="type">CustomClassLoader</span> <span class="variable">customClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomClassLoader</span>(); <span class="comment">// 自定义类加载器实例</span></span><br><span class="line">        Class&lt;?&gt; testClass2 = customClassLoader.loadClass(<span class="string">&quot;com.test.Test&quot;</span>); <span class="comment">// 使用自定义类加载器加载类</span></span><br><span class="line"></span><br><span class="line">        System.out.println(testClass1.getClassLoader()); <span class="comment">// 获取类加载器</span></span><br><span class="line">        System.out.println(testClass2.getClassLoader());</span><br><span class="line"></span><br><span class="line">        System.out.println(testClass1); <span class="comment">// 获取类的 Class 对象</span></span><br><span class="line">        System.out.println(testClass2);</span><br><span class="line"></span><br><span class="line">        System.out.println(testClass1 == testClass2); <span class="comment">// false</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> (Test) testClass2.newInstance(); <span class="comment">// 强制类型转换 -&gt; ClassCastException</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123; <span class="comment">// 自定义类加载器</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./target/classes/&quot;</span>+name.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>)+<span class="string">&quot;.class&quot;</span>)) &#123; <span class="comment">// 读取类文件的字节流</span></span><br><span class="line">                <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[stream.available()];</span><br><span class="line">                stream.read(data);</span><br><span class="line">                <span class="keyword">if</span>(data.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">super</span>.loadClass(name); <span class="comment">// 如果数据为空，则调用父类的加载方法</span></span><br><span class="line">                <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length); <span class="comment">// 定义类并返回</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.loadClass(name); <span class="comment">// 处理 IO 异常，调用父类的加载方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结论</strong>：</p>
<blockquote>
<p>即使两个类是同一个 Class 文件加载的，只要类加载器不同，那么这两个类就是不同的两个类</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kokoachino.github.io/1970/01/12/12%20JavaJVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/" data-id="cm35nehsx004u5ww4g0mx5rey" data-title="JavaJVM 虚拟机" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JNI/" rel="tag">JNI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JRE/" rel="tag">JRE</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">内存管理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" rel="tag">垃圾回收机制</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/" rel="tag">引用类型</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%B1%BB%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/" rel="tag">类与类加载</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/1970/02/01/01%20HTML/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          HTML
        
      </div>
    </a>
  
  
    <a href="/1970/01/11/11%20SpringBoot%20%E6%A1%86%E6%9E%B6/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">SpringBoot 框架</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOP/" rel="tag">AOP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/API/" rel="tag">API</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Axios/" rel="tag">Axios</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Banner/" rel="tag">Banner</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bean/" rel="tag">Bean</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bean-Aware/" rel="tag">Bean Aware</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boot/" rel="tag">Boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Controller/" rel="tag">Controller</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cookie/" rel="tag">Cookie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Document/" rel="tag">Document</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Element/" rel="tag">Element</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Element-plus/" rel="tag">Element-plus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Filter/" rel="tag">Filter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GUI/" rel="tag">GUI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HikariCP/" rel="tag">HikariCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HttpClient/" rel="tag">HttpClient</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HttpFilter/" rel="tag">HttpFilter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HttpServlet/" rel="tag">HttpServlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Interceptor/" rel="tag">Interceptor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDBC/" rel="tag">JDBC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JNI/" rel="tag">JNI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JPA/" rel="tag">JPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JRE/" rel="tag">JRE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSON/" rel="tag">JSON</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JUL/" rel="tag">JUL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JUnit/" rel="tag">JUnit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lambda/" rel="tag">Lambda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lombok/" rel="tag">Lombok</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Matlab/" rel="tag">Matlab</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/" rel="tag">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mvc/" rel="tag">Mvc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MybatisPlus/" rel="tag">MybatisPlus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Optional/" rel="tag">Optional</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Promise/" rel="tag">Promise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Properties/" rel="tag">Properties</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RestFul/" rel="tag">RestFul</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Robot/" rel="tag">Robot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Security/" rel="tag">Security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Servlet/" rel="tag">Servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ServletContext/" rel="tag">ServletContext</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Session/" rel="tag">Session</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Slf4j/" rel="tag">Slf4j</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringEL/" rel="tag">SpringEL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Stream-%E6%B5%81/" rel="tag">Stream 流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Thymeleaf/" rel="tag">Thymeleaf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Token/" rel="tag">Token</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vim/" rel="tag">Vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vuex/" rel="tag">Vuex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XHR/" rel="tag">XHR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/" rel="tag">XML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/router/" rel="tag">router</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/switch/" rel="tag">switch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E4%BB%B6/" rel="tag">事件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%A4%E4%BA%92/" rel="tag">交互</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/" rel="tag">任务调度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%87%BD%E6%95%B0/" rel="tag">函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/" rel="tag">函数式接口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E6%94%AF/" rel="tag">分支</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8D%E5%B0%84/" rel="tag">反射</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%91%BD%E4%BB%A4/" rel="tag">命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/" rel="tag">图像绘制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" rel="tag">垃圾回收机制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/" rel="tag">存储过程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/" rel="tag">定时器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%B9%E8%AF%9D%E6%A1%86/" rel="tag">对话框</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B1%9E%E6%80%A7/" rel="tag">属性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B8%83%E5%B1%80/" rel="tag">布局</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8/" rel="tag">异常处理器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/" rel="tag">引用类型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8C%81%E4%B9%85%E5%8C%96/" rel="tag">持久化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag">数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" rel="tag">数据类型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97/" rel="tag">数据统计与计算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6/" rel="tag">文件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/" rel="tag">文件传输</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E6%9C%AC%E5%9D%97/" rel="tag">文本块</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E7%89%B9%E6%80%A7/" rel="tag">新特性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%98%A0%E5%B0%84%E5%99%A8/" rel="tag">映射器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E5%9D%97/" rel="tag">模块</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/" rel="tag">正则匹配</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E8%A7%A3/" rel="tag">注解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B8%E6%A0%87/" rel="tag">游标</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9B%91%E5%90%AC%E5%99%A8/" rel="tag">监听器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AA%97%E5%8F%A3/" rel="tag">窗口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AC%A6%E5%8F%B7%E5%AF%B9%E8%B1%A1/" rel="tag">符号对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/" rel="tag">类与类加载</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E4%BB%B6/" rel="tag">组件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%8F%9C%E5%8D%95/" rel="tag">菜单</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%86%E5%9B%BE/" rel="tag">视图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%A6%E5%8F%91%E5%99%A8/" rel="tag">触发器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95/" rel="tag">语法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/" rel="tag">远程仓库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%89%E6%8B%A9%E5%99%A8/" rel="tag">选择器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%85%8D%E7%BD%AE/" rel="tag">配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E6%9D%BF/" rel="tag">面板</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AOP/" style="font-size: 10px;">AOP</a> <a href="/tags/API/" style="font-size: 10px;">API</a> <a href="/tags/Axios/" style="font-size: 10px;">Axios</a> <a href="/tags/Banner/" style="font-size: 10px;">Banner</a> <a href="/tags/Bean/" style="font-size: 12px;">Bean</a> <a href="/tags/Bean-Aware/" style="font-size: 10px;">Bean Aware</a> <a href="/tags/Boot/" style="font-size: 10px;">Boot</a> <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Controller/" style="font-size: 10px;">Controller</a> <a href="/tags/Cookie/" style="font-size: 10px;">Cookie</a> <a href="/tags/Document/" style="font-size: 10px;">Document</a> <a href="/tags/Element/" style="font-size: 10px;">Element</a> <a href="/tags/Element-plus/" style="font-size: 10px;">Element-plus</a> <a href="/tags/Filter/" style="font-size: 10px;">Filter</a> <a href="/tags/GUI/" style="font-size: 10px;">GUI</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/HikariCP/" style="font-size: 10px;">HikariCP</a> <a href="/tags/HttpClient/" style="font-size: 10px;">HttpClient</a> <a href="/tags/HttpFilter/" style="font-size: 10px;">HttpFilter</a> <a href="/tags/HttpServlet/" style="font-size: 10px;">HttpServlet</a> <a href="/tags/Interceptor/" style="font-size: 10px;">Interceptor</a> <a href="/tags/JDBC/" style="font-size: 10px;">JDBC</a> <a href="/tags/JNI/" style="font-size: 10px;">JNI</a> <a href="/tags/JPA/" style="font-size: 10px;">JPA</a> <a href="/tags/JRE/" style="font-size: 10px;">JRE</a> <a href="/tags/JSON/" style="font-size: 10px;">JSON</a> <a href="/tags/JUL/" style="font-size: 10px;">JUL</a> <a href="/tags/JUnit/" style="font-size: 12px;">JUnit</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Lambda/" style="font-size: 10px;">Lambda</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Lombok/" style="font-size: 10px;">Lombok</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/Matlab/" style="font-size: 10px;">Matlab</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/Mvc/" style="font-size: 10px;">Mvc</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Mybatis/" style="font-size: 10px;">Mybatis</a> <a href="/tags/MybatisPlus/" style="font-size: 10px;">MybatisPlus</a> <a href="/tags/Optional/" style="font-size: 10px;">Optional</a> <a href="/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/tags/Properties/" style="font-size: 10px;">Properties</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/RestFul/" style="font-size: 10px;">RestFul</a> <a href="/tags/Robot/" style="font-size: 10px;">Robot</a> <a href="/tags/Security/" style="font-size: 10px;">Security</a> <a href="/tags/Servlet/" style="font-size: 10px;">Servlet</a> <a href="/tags/ServletContext/" style="font-size: 10px;">ServletContext</a> <a href="/tags/Session/" style="font-size: 12px;">Session</a> <a href="/tags/Slf4j/" style="font-size: 10px;">Slf4j</a> <a href="/tags/Spring/" style="font-size: 16px;">Spring</a> <a href="/tags/SpringEL/" style="font-size: 10px;">SpringEL</a> <a href="/tags/Stream-%E6%B5%81/" style="font-size: 10px;">Stream 流</a> <a href="/tags/Thymeleaf/" style="font-size: 10px;">Thymeleaf</a> <a href="/tags/Token/" style="font-size: 10px;">Token</a> <a href="/tags/Vim/" style="font-size: 10px;">Vim</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/Vuex/" style="font-size: 10px;">Vuex</a> <a href="/tags/Web/" style="font-size: 20px;">Web</a> <a href="/tags/XHR/" style="font-size: 10px;">XHR</a> <a href="/tags/XML/" style="font-size: 12px;">XML</a> <a href="/tags/router/" style="font-size: 10px;">router</a> <a href="/tags/switch/" style="font-size: 10px;">switch</a> <a href="/tags/%E4%BA%8B%E4%BB%B6/" style="font-size: 12px;">事件</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 16px;">事务</a> <a href="/tags/%E4%BA%A4%E4%BA%92/" style="font-size: 16px;">交互</a> <a href="/tags/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/" style="font-size: 10px;">任务调度</a> <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">内存管理</a> <a href="/tags/%E5%87%BD%E6%95%B0/" style="font-size: 16px;">函数</a> <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/" style="font-size: 10px;">函数式接口</a> <a href="/tags/%E5%88%86%E6%94%AF/" style="font-size: 10px;">分支</a> <a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 10px;">反射</a> <a href="/tags/%E5%91%BD%E4%BB%A4/" style="font-size: 12px;">命令</a> <a href="/tags/%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6/" style="font-size: 10px;">图像绘制</a> <a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" style="font-size: 10px;">垃圾回收机制</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 10px;">多线程</a> <a href="/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/" style="font-size: 10px;">存储过程</a> <a href="/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/" style="font-size: 12px;">定时器</a> <a href="/tags/%E5%AF%B9%E8%AF%9D%E6%A1%86/" style="font-size: 10px;">对话框</a> <a href="/tags/%E5%B1%9E%E6%80%A7/" style="font-size: 12px;">属性</a> <a href="/tags/%E5%B8%83%E5%B1%80/" style="font-size: 10px;">布局</a> <a href="/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8/" style="font-size: 10px;">异常处理器</a> <a href="/tags/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/" style="font-size: 10px;">引用类型</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 10px;">性能优化</a> <a href="/tags/%E6%8C%81%E4%B9%85%E5%8C%96/" style="font-size: 10px;">持久化</a> <a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 12px;">数学</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 12px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" style="font-size: 16px;">数据类型</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E4%B8%8E%E8%AE%A1%E7%AE%97/" style="font-size: 10px;">数据统计与计算</a> <a href="/tags/%E6%96%87%E4%BB%B6/" style="font-size: 10px;">文件</a> <a href="/tags/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/" style="font-size: 12px;">文件传输</a> <a href="/tags/%E6%96%87%E6%9C%AC%E5%9D%97/" style="font-size: 10px;">文本块</a> <a href="/tags/%E6%96%B0%E7%89%B9%E6%80%A7/" style="font-size: 10px;">新特性</a> <a href="/tags/%E6%98%A0%E5%B0%84%E5%99%A8/" style="font-size: 10px;">映射器</a> <a href="/tags/%E6%A8%A1%E5%9D%97/" style="font-size: 12px;">模块</a> <a href="/tags/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/" style="font-size: 10px;">正则匹配</a> <a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 18px;">注解</a> <a href="/tags/%E6%B8%B8%E6%A0%87/" style="font-size: 10px;">游标</a> <a href="/tags/%E7%9B%91%E5%90%AC%E5%99%A8/" style="font-size: 14px;">监听器</a> <a href="/tags/%E7%AA%97%E5%8F%A3/" style="font-size: 10px;">窗口</a> <a href="/tags/%E7%AC%A6%E5%8F%B7%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">符号对象</a> <a href="/tags/%E7%B1%BB%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/" style="font-size: 10px;">类与类加载</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BB%84%E4%BB%B6/" style="font-size: 12px;">组件</a> <a href="/tags/%E8%8F%9C%E5%8D%95/" style="font-size: 10px;">菜单</a> <a href="/tags/%E8%A7%86%E5%9B%BE/" style="font-size: 10px;">视图</a> <a href="/tags/%E8%A7%A6%E5%8F%91%E5%99%A8/" style="font-size: 10px;">触发器</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E8%AF%AD%E6%B3%95/" style="font-size: 20px;">语法</a> <a href="/tags/%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/" style="font-size: 10px;">远程仓库</a> <a href="/tags/%E9%80%89%E6%8B%A9%E5%99%A8/" style="font-size: 10px;">选择器</a> <a href="/tags/%E9%85%8D%E7%BD%AE/" style="font-size: 12px;">配置</a> <a href="/tags/%E9%94%81/" style="font-size: 14px;">锁</a> <a href="/tags/%E9%9D%A2%E6%9D%BF/" style="font-size: 10px;">面板</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/1970/04/">四月 1970</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/1970/03/">三月 1970</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/1970/02/">二月 1970</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/1970/01/">一月 1970</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/1970/04/02/02%20Matlab/">Matlab</a>
          </li>
        
          <li>
            <a href="/1970/04/01/01%20Markdown%20%E8%AF%AD%E6%B3%95/">Markdown 语法</a>
          </li>
        
          <li>
            <a href="/1970/03/04/04%20Redis%20%E6%95%B0%E6%8D%AE%E5%BA%93/">Redis 数据库</a>
          </li>
        
          <li>
            <a href="/1970/03/03/03%20Linux%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">Linux 操作系统</a>
          </li>
        
          <li>
            <a href="/1970/03/02/02%20Git%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/">Git 版本控制</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 星开祈灵<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>